
==================== FINAL INTERFACE ====================
2016-06-27 18:00:43.2602443 UTC

interface main@main:Main 7103
  interface hash: 46828d48f3c16d82d8a5ea842123196b
  ABI hash: 4ad51c687128af0bd709a410821523bd
  export-list hash: 265c977bbf5f0084575ad91b1f2bce29
  orphan hash: aa551dc51c40f55046fb8166241b48bf
  flag hash: 989d7567c2a4235d3a2ce5e5716544db
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.bitsToNum
  Main.buildEncodeDictionary
  Main.buildLutMapEncode
  Main.decode
  Main.deserialize
  Main.encode
  Main.fillLut
  Main.getProbability
  Main.gfxOffset
  Main.histogram
  Main.lutEntriesCount
  Main.main
  Main.mergeNybbles
  Main.numToBits
  Main.serialize
  Main.serializeLutMap
  Main.splitNybbles
  Main.toBitStream
  Main.toBoolStream
  Main.trimRlesLen
  Main.xorDecrypt
  Main.xorEncrypt
  Main.EncodeDictionary
  Main.LutEntry{Main.LutEntry Main.bitLen Main.rleCount Main.rleData}
  Main.LutMap
  Main.RleEntry{Main.Code Main.len Main.val}
  Main.StreamCounter{Main.StreamCounter Main.inVal Main.outVal Main.stream}
module dependencies:
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0
                      base-unicode-symbols-0.2.2.4@baseu_HARyL3klEFABQ7g2MPHMdz
                      binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi
                      bitstream-0.2.0.4@bitst_BQbLuh1SAyZJZAeLVOmcbb
                      bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6
                      containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8
                      primitive-0.6.1.0@primi_EphY2c7CCxSCBKjAN0YTR3
                      split-0.2.3@split_CDzOynTh4l8Ahg1HaWUL4Z
                      transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF
                      vector-0.10.12.3@vecto_Hlsuo0rfZGxDZa3vCL7yzy
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
         transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF:Control.Monad.Trans.Error
         vector-0.10.12.3@vecto_Hlsuo0rfZGxDZa3vCL7yzy:Data.Vector.Fusion.Stream
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
                         primitive-0.6.1.0@primi_EphY2c7CCxSCBKjAN0YTR3:Control.Monad.Primitive
                         vector-0.10.12.3@vecto_Hlsuo0rfZGxDZa3vCL7yzy:Data.Vector.Storable
import  -/  base-4.8.2.0:Data.Bits 87f514c5f0e66e224843da33c04aa38b
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.Int 1419fa899a36eeb2bd16fdb7f0a89738
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:Data.Ord 66127262fc269c8a61d7d87ba94bd4d2
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:Data.Word ec8deb535202352cc8b509b14004bcbd
import  -/  base-4.8.2.0:GHC.Base a4939789b2cfd60b36ed163e56a623cd
import  -/  base-4.8.2.0:GHC.Float e532d434ec2447d809887c0fca1d78a5
import  -/  base-4.8.2.0:GHC.Int 28d8a9f7cfc272358fb4631d98c579ce
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:GHC.Word 10dc88543d98000abab9695a1019767d
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:System.Environment c73e1b71c29d9e28d4cdf8209f2f1559
import  -/  base-4.8.2.0:System.IO 638c10c4fd4901a0aca5b77c9f14123d
import  -/  binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi:Data.Binary.Get f87c878c97e7480a92e049b12d3a9019
import  -/  binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi:Data.Binary.Put 3105ee566a5c25103f6c0c5075957d76
import  -/  bitstream-0.2.0.4@bitst_BQbLuh1SAyZJZAeLVOmcbb:Data.Bitstream.Generic 39a6b796feff3070e35ab70db4d7b386
import  -/  bitstream-0.2.0.4@bitst_BQbLuh1SAyZJZAeLVOmcbb:Data.Bitstream.Lazy 40fc5880692d139a37dde6f8a6e58b25
import  -/  bitstream-0.2.0.4@bitst_BQbLuh1SAyZJZAeLVOmcbb:Data.Bitstream.Packet 45e0b91d5eba71b4ab323d748f0ddded
import  -/  bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString.Lazy 59e7973423198e93620da16e5f7527dd
import  -/  bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString.Lazy.Internal be8c2313b6f0cc8907d9784ae8e9c59d
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base 0e2fa197eb6e9c9e1e1de95c3768f6ec
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Strict 835c6fadc5446acd8356b2317fd91a15
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8:Control.Monad.State 3c8114545920fee1e57c3d7a07c2d0d7
import  -/  mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8:Control.Monad.State.Class 521f2360d2f7cec1d4be0e199fde9ee2
import  -/  split-0.2.3@split_CDzOynTh4l8Ahg1HaWUL4Z:Data.List.Split 0ce5c537605fc9ad887ec02865b54394
import  -/  split-0.2.3@split_CDzOynTh4l8Ahg1HaWUL4Z:Data.List.Split.Internals 4ea5a9e5367ae0648c6ecbbc653cbd5b
import  -/  transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF:Control.Monad.Trans.State.Lazy 442cc9f80155d8aaed5b22580b659d92
cdab06891c26fc2e11afd700e725d743
  $fEqRleEntry :: GHC.Classes.Eq Main.RleEntry
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.RleEntry Main.$fEqRleEntry_$c== Main.$fEqRleEntry_$c/= -}
cdab06891c26fc2e11afd700e725d743
  $fEqRleEntry_$c/= ::
    Main.RleEntry -> Main.RleEntry -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U(U))><S(SL),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.RleEntry w1 :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Main.Code ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Main.$w$c/= ww4 ww2 ww9 ww7 } } } }) -}
cdab06891c26fc2e11afd700e725d743
  $fEqRleEntry_$c== ::
    Main.RleEntry -> Main.RleEntry -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U(U))><S(SL),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.RleEntry w1 :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Main.Code ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Main.$w$c== ww4 ww2 ww9 ww7 } } } }) -}
cdab06891c26fc2e11afd700e725d743
  $fOrdRleEntry :: GHC.Classes.Ord Main.RleEntry
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.RleEntry
                  Main.$fEqRleEntry
                  Main.$fOrdRleEntry_$ccompare
                  Main.$fOrdRleEntry_$c<
                  Main.$fOrdRleEntry_$c<=
                  Main.$fOrdRleEntry_$c>
                  Main.$fOrdRleEntry_$c>=
                  Main.$fOrdRleEntry_$cmax
                  Main.$fOrdRleEntry_$cmin -}
cdab06891c26fc2e11afd700e725d743
  $fOrdRleEntry_$c< ::
    Main.RleEntry -> Main.RleEntry -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U(U))><S(SL),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.RleEntry w1 :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Main.Code ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Main.$w$c< ww4 ww2 ww9 ww7 } } } }) -}
cdab06891c26fc2e11afd700e725d743
  $fOrdRleEntry_$c<= ::
    Main.RleEntry -> Main.RleEntry -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U(U))><S(SL),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.RleEntry w1 :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Main.Code ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Main.$w$c<= ww4 ww2 ww9 ww7 } } } }) -}
cdab06891c26fc2e11afd700e725d743
  $fOrdRleEntry_$c> ::
    Main.RleEntry -> Main.RleEntry -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U(U))><S(SL),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.RleEntry w1 :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Main.Code ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Main.$w$c> ww4 ww2 ww9 ww7 } } } }) -}
cdab06891c26fc2e11afd700e725d743
  $fOrdRleEntry_$c>= ::
    Main.RleEntry -> Main.RleEntry -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U(U))><S(SL),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.RleEntry w1 :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Main.Code ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Main.$w$c>= ww4 ww2 ww9 ww7 } } } }) -}
cdab06891c26fc2e11afd700e725d743
  $fOrdRleEntry_$ccompare ::
    Main.RleEntry -> Main.RleEntry -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U(U))><S(SL),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.RleEntry w1 :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Main.Code ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Main.$w$ccompare ww4 ww2 ww9 ww7 } } } }) -}
cdab06891c26fc2e11afd700e725d743
  $fOrdRleEntry_$cmax ::
    Main.RleEntry -> Main.RleEntry -> Main.RleEntry
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(U(U),U(U))><S(SL),1*U(U(U),U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.RleEntry w1 :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Main.Code ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww4 ww9) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww4 ww9) of wild1 {
                        GHC.Types.False -> Main.Code (GHC.Types.I# ww4) ww2
                        GHC.Types.True
                        -> case ww2 of wild2 { GHC.Word.W8# a9 ->
                           case ww7 of wild3 { GHC.Word.W8# b1 ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.leWord# a9 b1) of wild4 {
                             GHC.Types.False -> Main.Code (GHC.Types.I# ww4) wild2
                             GHC.Types.True -> Main.Code (GHC.Types.I# ww9) wild3 } } } }
                   GHC.Types.True -> Main.Code (GHC.Types.I# ww9) ww7 } } } } }) -}
cdab06891c26fc2e11afd700e725d743
  $fOrdRleEntry_$cmin ::
    Main.RleEntry -> Main.RleEntry -> Main.RleEntry
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(U(U),U(U))><S(SL),1*U(U(U),U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.RleEntry w1 :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Main.Code ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww4 ww9) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww4 ww9) of wild1 {
                        GHC.Types.False -> Main.Code (GHC.Types.I# ww9) ww7
                        GHC.Types.True
                        -> case ww2 of wild2 { GHC.Word.W8# a9 ->
                           case ww7 of wild3 { GHC.Word.W8# b1 ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.leWord# a9 b1) of wild4 {
                             GHC.Types.False -> Main.Code (GHC.Types.I# ww9) wild3
                             GHC.Types.True -> Main.Code (GHC.Types.I# ww4) wild2 } } } }
                   GHC.Types.True -> Main.Code (GHC.Types.I# ww4) ww2 } } } } }) -}
4ce99a07c18d78ddfad825ae77e37759
  $fShowLutEntry :: GHC.Show.Show Main.LutEntry
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.LutEntry
                  Main.$fShowLutEntry_$cshowsPrec
                  Main.$fShowLutEntry_$cshow
                  Main.$fShowLutEntry_$cshowList -}
4ce99a07c18d78ddfad825ae77e37759
  $fShowLutEntry1 :: Main.LutEntry -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Main.LutEntry w1 :: GHC.Base.String ->
                 case w of ww { Main.LutEntry ww1 ww2 ww3 ->
                 Main.$w$cshowsPrec 0 ww1 ww2 ww3 w1 }) -}
864e22ac290c470fe81a6762d814d0c7
  $fShowLutEntry2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
9b29ce10f7bfc2714b9feb51aca0f9ea
  $fShowLutEntry3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "rleData = "#) -}
19b777c01a0feb9ca60f2ae81d7a2913
  $fShowLutEntry4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "rleCount = "#) -}
04df27a9f3eacc3c6dce83db21991117
  $fShowLutEntry5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
5ce36792c0f9a3503322d05e44b582d1
  $fShowLutEntry6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "bitLen = "#) -}
b1133da842de50a72fb6e7378106e69e
  $fShowLutEntry7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LutEntry {"#) -}
4ce99a07c18d78ddfad825ae77e37759
  $fShowLutEntry_$cshow :: Main.LutEntry -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(U),1*U(U),1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Main.LutEntry ->
                 Main.$fShowLutEntry_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
4ce99a07c18d78ddfad825ae77e37759
  $fShowLutEntry_$cshowList :: [Main.LutEntry] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Main.LutEntry
                   Main.$fShowLutEntry1) -}
4ce99a07c18d78ddfad825ae77e37759
  $fShowLutEntry_$cshowsPrec ::
    GHC.Types.Int -> Main.LutEntry -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <S,1*U(U)><S,1*U(1*U(U),1*U(U),1*U(U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Main.LutEntry w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Main.LutEntry ww3 ww4 ww5 ->
                 Main.$w$cshowsPrec ww1 ww3 ww4 ww5 w2 } }) -}
cdab06891c26fc2e11afd700e725d743
  $fShowRleEntry :: GHC.Show.Show Main.RleEntry
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.RleEntry
                  Main.$fShowRleEntry_$cshowsPrec
                  Main.$fShowRleEntry_$cshow
                  Main.$fShowRleEntry_$cshowList -}
cdab06891c26fc2e11afd700e725d743
  $fShowRleEntry1 :: Main.RleEntry -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Main.RleEntry w1 :: GHC.Base.String ->
                 case w of ww { Main.Code ww1 ww2 ->
                 Main.$w$cshowsPrec1 0 ww1 ww2 w1 }) -}
5ed04ce684b10ac13101118f65de4d30
  $fShowRleEntry2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Code {"#) -}
781f140e12c7569279a199eb7ff0f347
  $fShowRleEntry3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "val = "#) -}
40c128be78292b1a4a35d686bd56b0f2
  $fShowRleEntry4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "len = "#) -}
cdab06891c26fc2e11afd700e725d743
  $fShowRleEntry_$cshow :: Main.RleEntry -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(U),1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Main.RleEntry ->
                 Main.$fShowRleEntry_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
cdab06891c26fc2e11afd700e725d743
  $fShowRleEntry_$cshowList :: [Main.RleEntry] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Main.RleEntry
                   Main.$fShowRleEntry1) -}
cdab06891c26fc2e11afd700e725d743
  $fShowRleEntry_$cshowsPrec ::
    GHC.Types.Int -> Main.RleEntry -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U(U),1*U(U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Main.RleEntry w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Main.Code ww3 ww4 ->
                 Main.$w$cshowsPrec1 ww1 ww3 ww4 w2 } }) -}
b8f2d02f49c6d75ec6b80e7ddf31261b
  $sconcatMap :: (a3 -> [b]) -> [a3] -> [b]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a9 @ b f :: a9 -> [b] xs :: [a9] ->
                 GHC.Base.build
                   @ b
                   (\ @ b1 c :: b -> b1 -> b1[OneShot] n :: b1[OneShot] ->
                    GHC.Base.foldr
                      @ a9
                      @ b1
                      (\ x :: a9 b2 :: b1[OneShot] -> GHC.Base.foldr @ b @ b1 c b2 (f x))
                      n
                      xs)) -}
9b2cd111b6fc955da016c072f829a03c
  $sfromListWith_$sfromListWithKey ::
    (Main.RleEntry -> a -> a -> a)
    -> [(Main.RleEntry, a)] -> Data.Map.Base.Map Main.RleEntry a
  {- Arity: 2, Strictness: <L,C(C1(C1(U)))><S,1*U>,
     Unfolding: (\ @ a9
                   f :: Main.RleEntry -> a9 -> a9 -> a9
                   xs :: [(Main.RleEntry, a9)] ->
                 letrec {
                   go4 :: Data.Map.Base.Map Main.RleEntry a9
                          -> [(Main.RleEntry, a9)] -> Data.Map.Base.Map Main.RleEntry a9
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ z :: Data.Map.Base.Map Main.RleEntry a9
                       ds :: [(Main.RleEntry, a9)] ->
                     case ds of wild {
                       [] -> z
                       : x xs1
                       -> case x of wild1 { (,) k1 x1 ->
                          case k1 of ww { Main.Code ww1 ww2 ->
                          case Main.$w$sgo4 @ a9 f ww1 ww2 x1 z of z' { DEFAULT ->
                          go4 z' xs1 } } } }
                 } in
                 go4 (Data.Map.Base.Tip @ Main.RleEntry @ a9) xs) -}
882fc718688b8af6fb58967bcf802ca5
  $spack ::
    [GHC.Types.Bool]
    -> Data.Bitstream.Lazy.Bitstream Data.Bitstream.Packet.Right
  {- Arity: 1, Strictness: <L,U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (let {
                   f :: Data.Vector.Fusion.Stream.Stream GHC.Types.Bool
                        -> Data.Bitstream.Lazy.Bitstream Data.Bitstream.Packet.Right
                   = Data.Bitstream.Generic.unstream
                       @ (Data.Bitstream.Lazy.Bitstream Data.Bitstream.Packet.Right)
                       Data.Bitstream.Lazy.$fBitstreamBitstream
                 } in
                 \ x :: [GHC.Types.Bool] ->
                 f (Data.Vector.Fusion.Stream.$sfromList @ GHC.Types.Bool x)) -}
de52de53e9955a0a85f716dd06928faf
  $stoByteString ::
    Data.Bitstream.Bitstream Data.Bitstream.Packet.Right
    -> Data.ByteString.Internal.ByteString
  {- Arity: 1, Strictness: <L,U> -}
ab9316695c12ae1b397cea2d739805ca
  $w$c/= ::
    GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Word.Word8
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Word.Word8 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Word.W8# a9 ->
                      case ww3 of wild2 { GHC.Word.W8# b1 ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# a9 b1) of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
3ff78991e2e104b9199c1f704a2f16b0
  $w$c< ::
    GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Word.Word8
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Word.Word8 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww ww2) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww ww2) of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> GHC.Word.$fOrdWord8_$c< ww1 ww3 }
                   GHC.Types.True -> GHC.Types.True }) -}
29b8259a908ccfa25d262a6e0c8ec522
  $w$c<= ::
    GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Word.Word8
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Word.Word8 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww ww2) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww ww2) of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> GHC.Word.$fOrdWord8_$c<= ww1 ww3 }
                   GHC.Types.True -> GHC.Types.True }) -}
68582b1f1f5f83fbfb0e178504e4ebbd
  $w$c== ::
    GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Word.Word8
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Word.Word8 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> GHC.Word.$fEqWord8_$c== ww1 ww3 }) -}
c02802f3f4659e60560123b74726d71b
  $w$c> ::
    GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Word.Word8
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Word.Word8 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww ww2) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww ww2) of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Word.$fOrdWord8_$c> ww1 ww3 }
                   GHC.Types.True -> GHC.Types.False }) -}
1f8874cf404d2367f352098589698f05
  $w$c>= ::
    GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Word.Word8
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Word.Word8 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww ww2) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww ww2) of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Word.$fOrdWord8_$c>= ww1 ww3 }
                   GHC.Types.True -> GHC.Types.False }) -}
748b66b87894d69ddf9d5dd5dc35964c
  $w$ccompare ::
    GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Types.Ordering
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Word.Word8
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Word.Word8 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww ww2) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww ww2) of wild1 {
                        GHC.Types.False -> GHC.Types.GT
                        GHC.Types.True -> GHC.Word.$fOrdWord8_$ccompare ww1 ww3 }
                   GHC.Types.True -> GHC.Types.LT }) -}
0ec77880343d5ce843630dd794f15821
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Word.Word8
    -> GHC.Word.Word8
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 5, Strictness: <L,U><L,1*U(U)><L,1*U(U)><L,1*U(U)><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Word.Word8
                   ww2 :: GHC.Word.Word8
                   ww3 :: GHC.Word.Word8
                   w :: GHC.Base.String ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Main.$fShowLutEntry7
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Main.$fShowLutEntry6
                          (case ww1 of wild { GHC.Word.W8# x# ->
                           let {
                             ww4 :: GHC.Prim.Int# = GHC.Prim.word2Int# x#
                           } in
                           let {
                             w1 :: GHC.Base.String
                             = GHC.Base.++
                                 @ GHC.Types.Char
                                 Main.$fShowLutEntry5
                                 (GHC.Base.++
                                    @ GHC.Types.Char
                                    Main.$fShowLutEntry4
                                    (case ww2 of wild1 { GHC.Word.W8# x#1 ->
                                     let {
                                       ww5 :: GHC.Prim.Int# = GHC.Prim.word2Int# x#1
                                     } in
                                     let {
                                       w2 :: GHC.Base.String
                                       = GHC.Base.++
                                           @ GHC.Types.Char
                                           Main.$fShowLutEntry5
                                           (GHC.Base.++
                                              @ GHC.Types.Char
                                              Main.$fShowLutEntry3
                                              (case ww3 of wild2 { GHC.Word.W8# x#2 ->
                                               let {
                                                 ww6 :: GHC.Prim.Int# = GHC.Prim.word2Int# x#2
                                               } in
                                               case GHC.Prim.tagToEnum#
                                                      @ GHC.Types.Bool
                                                      (GHC.Prim.<# ww6 0) of wild3 {
                                                 GHC.Types.False
                                                 -> case GHC.Show.$witos
                                                           ww6
                                                           (GHC.Base.++
                                                              @ GHC.Types.Char
                                                              Main.$fShowLutEntry2
                                                              x) of ww7 { (#,#) ww8 ww9 ->
                                                    GHC.Types.: @ GHC.Types.Char ww8 ww9 }
                                                 GHC.Types.True
                                                 -> case GHC.Show.$witos
                                                           ww6
                                                           (GHC.Base.++
                                                              @ GHC.Types.Char
                                                              Main.$fShowLutEntry2
                                                              x) of ww7 { (#,#) ww8 ww9 ->
                                                    GHC.Types.: @ GHC.Types.Char ww8 ww9 } } }))
                                     } in
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.<# ww5 0) of wild2 {
                                       GHC.Types.False
                                       -> case GHC.Show.$witos ww5 w2 of ww6 { (#,#) ww7 ww8 ->
                                          GHC.Types.: @ GHC.Types.Char ww7 ww8 }
                                       GHC.Types.True
                                       -> case GHC.Show.$witos ww5 w2 of ww6 { (#,#) ww7 ww8 ->
                                          GHC.Types.: @ GHC.Types.Char ww7 ww8 } } }))
                           } in
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<# ww4 0) of wild1 {
                             GHC.Types.False
                             -> case GHC.Show.$witos ww4 w1 of ww5 { (#,#) ww6 ww7 ->
                                GHC.Types.: @ GHC.Types.Char ww6 ww7 }
                             GHC.Types.True
                             -> case GHC.Show.$witos ww4 w1 of ww5 { (#,#) ww6 ww7 ->
                                GHC.Types.: @ GHC.Types.Char ww6 ww7 } } }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w)) }) -}
5c92b9377afba59c081f467e1263dd0a
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Word.Word8
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><L,1*U(U)><L,1*U(U)><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Types.Int
                   ww2 :: GHC.Word.Word8
                   w :: GHC.Base.String ->
                 let {
                   g1 :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Main.$fShowRleEntry4
                       (case ww1 of ww3 { GHC.Types.I# ww4 ->
                        case GHC.Show.$wshowSignedInt
                               0
                               ww4
                               (GHC.Base.++
                                  @ GHC.Types.Char
                                  Main.$fShowLutEntry5
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     Main.$fShowRleEntry3
                                     (case ww2 of wild { GHC.Word.W8# x# ->
                                      let {
                                        ww5 :: GHC.Prim.Int# = GHC.Prim.word2Int# x#
                                      } in
                                      case GHC.Prim.tagToEnum#
                                             @ GHC.Types.Bool
                                             (GHC.Prim.<# ww5 0) of wild1 {
                                        GHC.Types.False
                                        -> case GHC.Show.$witos
                                                  ww5
                                                  (GHC.Base.++
                                                     @ GHC.Types.Char
                                                     Main.$fShowLutEntry2
                                                     x) of ww6 { (#,#) ww7 ww8 ->
                                           GHC.Types.: @ GHC.Types.Char ww7 ww8 }
                                        GHC.Types.True
                                        -> case GHC.Show.$witos
                                                  ww5
                                                  (GHC.Base.++
                                                     @ GHC.Types.Char
                                                     Main.$fShowLutEntry2
                                                     x) of ww6 { (#,#) ww7 ww8 ->
                                           GHC.Types.:
                                             @ GHC.Types.Char
                                             ww7
                                             ww8 } } }))) of ww5 { (#,#) ww6 ww7 ->
                        GHC.Types.: @ GHC.Types.Char ww6 ww7 } })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++ @ GHC.Types.Char Main.$fShowRleEntry2 (g1 w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Main.$fShowRleEntry2
                           (g1 (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
f8fe3c7a3e9c440ee55e200fcc0f7ddb
  $w$sgo1 ::
    GHC.Types.Int
    -> GHC.Word.Word8
    -> a1
    -> Data.Map.Base.Map Main.RleEntry a1
    -> Data.Map.Base.Map Main.RleEntry a1
  {- Arity: 4, Strictness: <L,U(U)><L,U(U)><S,1*U><S,1*U>,
     Inline: [0] -}
abd638a7a8c35fe01c10f2061bafd922
  $w$sgo2 ::
    GHC.Prim.Word#
    -> a1
    -> Data.Map.Base.Map GHC.Word.Word8 a1
    -> Data.Map.Base.Map GHC.Word.Word8 a1
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>, Inline: [0] -}
3e38bd2837a0f61f504731e4a47a7bfd
  $w$sgo4 ::
    (Main.RleEntry -> a1 -> a1 -> a1)
    -> GHC.Types.Int
    -> GHC.Word.Word8
    -> a1
    -> Data.Map.Base.Map Main.RleEntry a1
    -> Data.Map.Base.Map Main.RleEntry a1
  {- Arity: 5,
     Strictness: <L,1*C1(C1(C1(U)))><L,U(U)><L,U(U)><L,U><S,1*U>,
     Inline: [0] -}
cb93fec20b3825b3956a53bacec5e129
  $wa ::
    [GHC.Word.Word8]
    -> GHC.Word.Word8
    -> GHC.Types.Int
    -> (# Main.LutMap, Main.StreamCounter GHC.Word.Word8 #)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,1*U(U)>, Inline: [0] -}
21c36182631397a2995231027affc17e
  $wf :: GHC.Prim.Word# -> GHC.Prim.Word# -> GHC.Prim.Word#
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0] -}
bee59ec7e96692c1a2522467c0d906ac
  $wgetProbability :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Types.Int
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ww1 :: GHC.Prim.Int# ->
                 case GHC.Prim./##
                        (GHC.Prim.int2Double# ww)
                        (GHC.Prim.int2Double# ww1) of wild2 { DEFAULT ->
                 let {
                   x :: GHC.Prim.Double# = GHC.Prim.*## wild2 252.0
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<## x 1.0) of wild {
                   GHC.Types.False
                   -> case {__pkg_ccall base-4.8.2.0 rintDouble GHC.Prim.Double#
                                                                -> GHC.Prim.State#
                                                                     GHC.Prim.RealWorld
                                                                -> (# GHC.Prim.State#
                                                                        GHC.Prim.RealWorld,
                                                                      GHC.Prim.Double# #)}
                             x
                             GHC.Prim.realWorld# of wild1 { (#,#) ds2 ds3 ->
                      let {
                        x1 :: GHC.Prim.Int# = GHC.Prim.double2Int# ds3
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# x1 2) of wild3 {
                        GHC.Types.False
                        -> case GHC.Prim.logDouble# x of wild4 { DEFAULT ->
                           case GHC.Prim.logDouble# 2.0 of wild5 { DEFAULT ->
                           case GHC.Prim./## wild4 wild5 of wild6 { DEFAULT ->
                           let {
                             n :: GHC.Prim.Int# = GHC.Prim.double2Int# wild6
                           } in
                           let {
                             $w$j :: GHC.Prim.Int# -> GHC.Types.Int
                               {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                             = \ w :: GHC.Prim.Int#[OneShot] ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.<# w 0) of wild7 {
                                 GHC.Types.False
                                 -> let {
                                      $j :: GHC.Prim.Int# -> GHC.Types.Int -> GHC.Types.Int
                                        {- Arity: 2, Strictness: <L,U><L,1*U(U)> -}
                                      = \ i :: GHC.Prim.Int#[OneShot]
                                          wild8 :: GHC.Types.Int[OneShot] ->
                                        let {
                                          x2 :: GHC.Prim.Int# = GHC.Prim.+# w 1
                                        } in
                                        case GHC.Prim.tagToEnum#
                                               @ GHC.Types.Bool
                                               (GHC.Prim.<# x2 0) of wild9 {
                                          GHC.Types.False
                                          -> case x2 of wild10 {
                                               DEFAULT
                                               -> case GHC.Real.$wf1 2 wild10 of ww4 { DEFAULT ->
                                                  case GHC.Prim.tagToEnum#
                                                         @ GHC.Types.Bool
                                                         (GHC.Prim.>##
                                                            (GHC.Prim.-##
                                                               x
                                                               (GHC.Prim.int2Double# i))
                                                            (GHC.Prim.-##
                                                               (GHC.Prim.int2Double# ww4)
                                                               x)) of wild11 {
                                                    GHC.Types.False -> wild8
                                                    GHC.Types.True -> GHC.Types.I# ww4 } }
                                               0
                                               -> case GHC.Prim.tagToEnum#
                                                         @ GHC.Types.Bool
                                                         (GHC.Prim.>##
                                                            (GHC.Prim.-##
                                                               x
                                                               (GHC.Prim.int2Double# i))
                                                            (GHC.Prim.-## 1.0 x)) of wild11 {
                                                    GHC.Types.False -> wild8
                                                    GHC.Types.True -> GHC.Real.^3 } }
                                          GHC.Types.True -> GHC.Real.^2 }
                                    } in
                                    case w of wild8 {
                                      DEFAULT
                                      -> case GHC.Real.$wf1 2 wild8 of ww4 { DEFAULT ->
                                         $j ww4 (GHC.Types.I# ww4) }
                                      0 -> $j 1 GHC.Real.^3 }
                                 GHC.Types.True -> GHC.Real.^2 }
                           } in
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<## wild6 (GHC.Prim.int2Double# n)) of wild7 {
                             GHC.Types.False -> $w$j n
                             GHC.Types.True -> $w$j (GHC.Prim.-# n 1) } } } }
                        GHC.Types.True -> GHC.Types.I# x1 } }
                   GHC.Types.True -> Main.bitsToNum3 } }) -}
4b1c4b91147827fc228bdfeb526353a3
  $wlvl :: GHC.Prim.Word# -> GHC.Prim.Word# -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Word# ww1 :: GHC.Prim.Word# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.ltWord# ww ww1) of wild2 {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# ww ww1) of wild3 {
                        GHC.Types.False -> GHC.Types.GT GHC.Types.True -> GHC.Types.EQ }
                   GHC.Types.True -> GHC.Types.LT }) -}
77bfac9f741ad89eb6f8f5a51584a5ab
  $wnumToBits ::
    Data.Bits.Bits a => GHC.Prim.Int# -> a -> [GHC.Types.Bool]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a9
                   w :: Data.Bits.Bits a9
                   ww :: GHC.Prim.Int#
                   w1 :: a9 ->
                 let {
                   x1 :: GHC.Prim.Int# = GHC.Prim.-# ww 1
                 } in
                 let {
                   x2 :: GHC.Prim.Int# = GHC.Prim.-# ww 2
                 } in
                 let {
                   f :: GHC.Types.Int -> GHC.Types.Bool = Data.Bits.testBit @ a9 w w1
                 } in
                 let {
                   c :: GHC.Types.Int -> [GHC.Types.Bool] -> [GHC.Types.Bool]
                     {- Arity: 2, Strictness: <L,U><L,U>,
                        Unfolding: InlineRule (2, True, False)
                                   (\ x :: GHC.Types.Int ys :: [GHC.Types.Bool] ->
                                    GHC.Types.: @ GHC.Types.Bool (f x) ys) -}
                   = \ x :: GHC.Types.Int ys :: [GHC.Types.Bool][OneShot] ->
                     GHC.Types.: @ GHC.Types.Bool (f x) ys
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x2 x1) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB
                        @ [GHC.Types.Bool]
                        c
                        (GHC.Types.[] @ GHC.Types.Bool)
                        x1
                        x2
                        0
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB
                        @ [GHC.Types.Bool]
                        c
                        (GHC.Types.[] @ GHC.Types.Bool)
                        x1
                        x2
                        0 }) -}
c840067bfd1f5f535a6ea427e6e7e4b8
  $wpoly_go10 ::
    GHC.Types.Int
    -> GHC.Word.Word8
    -> Data.Map.Base.Map Main.RleEntry a
    -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(U)><L,U(U)><S,1*U>,
     Inline: [0] -}
b8c1410f557195b36828c559763216b3
  $wpoly_goNothing ::
    GHC.Prim.Word#
    -> Data.Map.Base.Map GHC.Word.Word8 v
    -> GHC.Base.Maybe (GHC.Word.Word8, v)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>, Inline: [0] -}
16defde1041769e97cb403340eb9f96e
  $wserializeMap ::
    GHC.Word.Word8
    -> [(GHC.Word.Word8, Main.LutEntry)]
    -> (# GHC.Word.Word8, [GHC.Word.Word8] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U>,
     Inline: [0] -}
358c4291eef2f73a15287f100682ff89
  $wtrimRleLen ::
    GHC.Prim.Int#
    -> GHC.Word.Word8 -> (# Main.RleEntry, [Main.RleEntry] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>, Inline: [0] -}
7aa60f4ab7e27773b4ed4fdcaf402f85
  type EncodeDictionary =
    Data.Map.Base.Map Main.RleEntry [GHC.Types.Bool]
4ce99a07c18d78ddfad825ae77e37759
  data LutEntry
    = LutEntry {bitLen :: GHC.Word.Word8,
                rleCount :: GHC.Word.Word8,
                rleData :: GHC.Word.Word8}
28de308d474d6a54a7afb241415c4275
  type LutMap = Data.Map.Base.Map GHC.Word.Word8 Main.LutEntry
cdab06891c26fc2e11afd700e725d743
  data RleEntry = Code {len :: GHC.Types.Int, val :: GHC.Word.Word8}
95224869bebfacab039479f63487a25b
  data StreamCounter a
    = StreamCounter {stream :: [a],
                     inVal :: GHC.Word.Word8,
                     outVal :: GHC.Types.Int}
812ca1f787543eec884d70c45f8295b9
  bitLen :: Main.LutEntry -> GHC.Word.Word8
  RecSel Main.LutEntry
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U(U),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.LutEntry ->
                 case ds of wild { Main.LutEntry ds1 ds2 ds3 -> ds1 }) -}
714028f7bb0fe7dea71acdaffdd8e6ea
  bitsToNum :: GHC.Num.Num a => [GHC.Types.Bool] -> a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))>,
     Unfolding: (\ @ a9 $dNum :: GHC.Num.Num a9 ->
                 let {
                   lvl30 :: a9 = GHC.Num.fromInteger @ a9 $dNum Main.bitsToNum7
                 } in
                 let {
                   lvl31 :: a9 = GHC.Num.fromInteger @ a9 $dNum Main.bitsToNum6
                 } in
                 let {
                   lvl32 :: a9 = GHC.Num.fromInteger @ a9 $dNum Main.bitsToNum5
                 } in
                 GHC.List.foldl'
                   @ GHC.Types.Bool
                   @ a9
                   (\ byte :: a9 b :: GHC.Types.Bool[OneShot] ->
                    GHC.Num.+
                      @ a9
                      $dNum
                      (GHC.Num.* @ a9 $dNum byte lvl30)
                      (case b of wild {
                         GHC.Types.False -> lvl31 GHC.Types.True -> lvl32 }))
                   lvl31) -}
e7565e0c6a5c117e539d53ce45d3b3f5
  bitsToNum1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 0) -}
45e0d333e24a320a83c086d571ee5bf2
  bitsToNum3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
cbc3ae2a1b21404ac2f74dae0d247eb3
  bitsToNum5 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 1) -}
aa18b5cc4ac902be2ed97850fa19b7d3
  bitsToNum6 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 0) -}
0d425216d8ae6c1b14d2150215aa4216
  bitsToNum7 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 2) -}
b5c8c118abeb20c71e66f59947549525
  buildEncodeDictionary :: Main.LutMap -> Main.EncodeDictionary
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ m :: Main.LutMap ->
                 Main.buildEncodeDictionary_go
                   (GHC.Base.build
                      @ (GHC.Word.Word8, Main.LutEntry)
                      (\ @ b
                         c :: (GHC.Word.Word8, Main.LutEntry) -> b -> b[OneShot]
                         n :: b[OneShot] ->
                       Data.Map.Base.foldrFB
                         @ GHC.Word.Word8
                         @ Main.LutEntry
                         @ b
                         (\ k1 :: GHC.Word.Word8
                            x :: Main.LutEntry[OneShot]
                            xs :: b[OneShot] ->
                          c (k1, x) xs)
                         n
                         m))) -}
bb3bb3052716435dc52d4d4583182496
  buildEncodeDictionary_go ::
    [(GHC.Word.Word8, Main.LutEntry)] -> Main.EncodeDictionary
  {- Arity: 1, Strictness: <S,1*U> -}
c6ea7399f0ecda168ad8a8abf6a831ea
  buildLutMapEncode ::
    [(GHC.Types.Int, Main.RleEntry)] -> Main.LutMap
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ xs :: [(GHC.Types.Int, Main.RleEntry)] ->
                 Main.buildLutMapEncode_go
                   (GHC.Base.build
                      @ Main.LutEntry
                      (\ @ b1 c :: Main.LutEntry -> b1 -> b1[OneShot] n :: b1[OneShot] ->
                       GHC.Base.foldr
                         @ (GHC.Types.Int, Main.RleEntry)
                         @ b1
                         (GHC.Base.mapFB
                            @ Main.LutEntry
                            @ b1
                            @ (GHC.Types.Int, Main.RleEntry)
                            c
                            Main.buildLutMapEncode1)
                         n
                         xs))
                   Main.bitsToNum1) -}
2d7430bf13a7c31a6505413eeb5572f6
  buildLutMapEncode1 ::
    (GHC.Types.Int, Main.RleEntry) -> Main.LutEntry
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS),1*U(1*U(U),1*U(1*U(U),U))>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: (GHC.Types.Int, Main.RleEntry) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww2 of ww3 { Main.Code ww4 ww5 ->
                 Main.LutEntry
                   (case ww1 of wild { GHC.Types.I# i ->
                    case GHC.Prim.logDouble#
                           (GHC.Prim.int2Double# i) of wild2 { DEFAULT ->
                    case GHC.Prim.logDouble# 2.0 of wild3 { DEFAULT ->
                    case GHC.Prim./## wild2 wild3 of wild4 { DEFAULT ->
                    case {__pkg_ccall base-4.8.2.0 rintDouble GHC.Prim.Double#
                                                              -> GHC.Prim.State# GHC.Prim.RealWorld
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Double# #)}
                           wild4
                           GHC.Prim.realWorld# of wild1 { (#,#) ds2 ds3 ->
                    GHC.Word.W8#
                      (GHC.Prim.narrow8Word#
                         (GHC.Prim.minusWord#
                            __word 8
                            (GHC.Prim.narrow8Word#
                               (GHC.Prim.int2Word# (GHC.Prim.double2Int# ds3))))) } } } } })
                   (case ww4 of wild { GHC.Types.I# x# ->
                    GHC.Word.W8# (GHC.Prim.narrow8Word# (GHC.Prim.int2Word# x#)) })
                   ww5 } }) -}
a49b2617675c14b7c2ac7f6f4184f0cb
  buildLutMapEncode_go ::
    [Main.LutEntry]
    -> GHC.Word.Word8 -> Data.Map.Base.Map GHC.Word.Word8 Main.LutEntry
  {- Arity: 2, Strictness: <S,1*U><L,1*U(U)> -}
175008ea788a6bb8609f063d1ef4344f
  decode :: GHC.Types.Int -> [Main.RleEntry] -> [GHC.Word.Word8]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U> -}
f7e6e2d86147996a669abce6c2766e86
  deserialize :: Main.LutMap -> [GHC.Types.Bool] -> [Main.RleEntry]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
373c258563d1625505f014f68f3c7c7a
  encode :: [GHC.Word.Word8] -> [Main.RleEntry]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: [GHC.Word.Word8] ->
                 GHC.Base.build
                   @ Main.RleEntry
                   (\ @ b1 c :: Main.RleEntry -> b1 -> b1[OneShot] n :: b1[OneShot] ->
                    GHC.Base.foldr
                      @ [GHC.Word.Word8]
                      @ b1
                      (GHC.Base.mapFB
                         @ Main.RleEntry
                         @ b1
                         @ [GHC.Word.Word8]
                         c
                         Main.encode1)
                      n
                      (Data.OldList.groupBy
                         @ GHC.Word.Word8
                         GHC.Word.$fEqWord8_$c==
                         x))) -}
b7e5e953d06305cf012b6666615b47c2
  encode1 :: [GHC.Word.Word8] -> Main.RleEntry
  {- Arity: 1, Strictness: <L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Word.Word8] ->
                 Main.Code
                   (case GHC.List.$wlenAcc @ GHC.Word.Word8 w 0 of ww2 { DEFAULT ->
                    GHC.Types.I# (GHC.Prim.-# ww2 1) })
                   (GHC.List.head @ GHC.Word.Word8 w)) -}
0bae5145a12f6d26066a60cea3fb8edf
  fillLut ::
    Control.Monad.Trans.State.Lazy.State
      (Main.StreamCounter GHC.Word.Word8) Main.LutMap
  {- Arity: 1, Strictness: <S(SLL),1*U(1*U,U,1*U(U))>m,
     Unfolding: InlineRule (0, True, True)
                Main.fillLut1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.NTCo:StateT[0]
                          <Main.StreamCounter GHC.Word.Word8>_N
                          <Data.Functor.Identity.Identity>_R
                          <Main.LutMap>_N)) -}
68befe79211a3523024ca479024fac82
  fillLut1 ::
    Main.StreamCounter GHC.Word.Word8
    -> Data.Functor.Identity.Identity
         (Main.LutMap, Main.StreamCounter GHC.Word.Word8)
  {- Arity: 1, Strictness: <S(SLL),1*U(1*U,U,1*U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: Main.StreamCounter GHC.Word.Word8 ->
                 case w of ww { Main.StreamCounter ww1 ww2 ww3 ->
                 case Main.$wa ww1 ww2 ww3 of ww4 { (#,#) ww5 ww6 ->
                 (ww5, ww6)
                   `cast`
                 (Sym (Data.Functor.Identity.NTCo:Identity[0]
                           <(Main.LutMap, Main.StreamCounter GHC.Word.Word8)>_R)) } }) -}
0c576cef0c6e3960cfb842fb79cb917f
  getProbability :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { GHC.Types.I# ww3 ->
                 Main.$wgetProbability ww1 ww3 } }) -}
c999ebc675d87be96310969b908b47c8
  gfxOffset :: GHC.Int.Int64
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Int.I64# 239104) -}
f908d536905df098640138b3dc112727
  histogram :: GHC.Classes.Ord a => [a] -> [(GHC.Types.Int, a)]
  {- Arity: 2, Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U>,
     Unfolding: (\ @ a9 $dOrd :: GHC.Classes.Ord a9 xs :: [a9] ->
                 Main.histogram4
                   @ a9
                   (GHC.Types.[] @ (GHC.Types.Int, a9))
                   (Data.Map.Strict.fromListWithKey
                      @ a9
                      @ GHC.Types.Int
                      $dOrd
                      (Main.histogram3 @ a9)
                      (Main.histogram2 @ a9 xs))) -}
2ab032a1365273fdf1b272e358c5cc30
  histogram1 ::
    Main.RleEntry -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 3, HasNoCafRefs,
     Unfolding: (\ ds :: Main.RleEntry
                   x :: GHC.Types.Int[OneShot]
                   y :: GHC.Types.Int[OneShot] ->
                 GHC.Num.$fNumInt_$c+ x y) -}
409e930ce9686dc5ceef8303acbb2cc2
  histogram2 :: [a] -> [(a, GHC.Types.Int)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
6ca48bf70b9a582d5798e02ff98e36d0
  histogram3 :: a -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 3, HasNoCafRefs,
     Unfolding: (\ @ a9
                   ds :: a9
                   x :: GHC.Types.Int[OneShot]
                   y :: GHC.Types.Int[OneShot] ->
                 GHC.Num.$fNumInt_$c+ x y) -}
f1618cb434a81f38ebc874f38d3c1163
  histogram4 ::
    [(GHC.Types.Int, a)]
    -> Data.Map.Base.Map a GHC.Types.Int -> [(GHC.Types.Int, a)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U> -}
01d1ef1bb2d9f85e6da82830c51ed5a8
  histogram_go :: [Main.RleEntry] -> [(Main.RleEntry, GHC.Types.Int)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
5678fc9f76d159c30f74eddc8f912bf4
  histogram_go10 ::
    [(GHC.Types.Int, Main.RleEntry)]
    -> Data.Map.Base.Map Main.RleEntry GHC.Types.Int
    -> [(GHC.Types.Int, Main.RleEntry)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U> -}
3a3dc43ada57bfabe731bab88b8371c4
  inVal :: Main.StreamCounter a -> GHC.Word.Word8
  RecSel Main.StreamCounter
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U(U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a9 ds :: Main.StreamCounter a9 ->
                 case ds of wild { Main.StreamCounter ds1 ds2 ds3 -> ds2 }) -}
b16aca4c63f18e56f49e0d7d1d30f3ec
  len :: Main.RleEntry -> GHC.Types.Int
  RecSel Main.RleEntry
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.RleEntry ->
                 case ds of wild { Main.Code ds1 ds2 -> ds1 }) -}
b76f4249e2ec2628fcd43fcd4de94a53
  lutEntriesCount :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 252) -}
c0c956c71406d9cb335182d05c0e3cf9
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
72c47377634a2c851da9a4c8ec9b7dbe
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case System.Environment.getArgs2 s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   GHC.Base.Nothing
                   -> case GHC.Environment.getFullArgs1
                             ipv of ds2 { (#,#) ipv2 ipv3 ->
                      case System.Environment.dropRTSArgs ipv3 of wild1 {
                        []
                        -> case GHC.List.scanl2
                           ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                           of {}
                        : ds3 xs -> Main.main2 xs ipv2 } }
                   GHC.Base.Just argv
                   -> Main.main2 (GHC.List.tail @ GHC.Base.String argv) ipv } }) -}
a57f186a8b3aee07f7a02ca2308bd280
  main2 ::
    [[GHC.Types.Char]]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
cfcdb000fe362b230a763b48f3e448fa
  main3 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R))) -}
ec0243367099e8bb8d666a5d8bb38b28
  mergeNybbles :: [GHC.Word.Word8] -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
7e1b0061e26cb3b87a160625e49b7aaf
  numToBits ::
    (Data.Bits.Bits a, GHC.Num.Num a) =>
    GHC.Types.Int -> a -> [GHC.Types.Bool]
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A)><L,A><S,1*U(U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a9
                   w :: Data.Bits.Bits a9
                   w1 :: GHC.Num.Num a9
                   w2 :: GHC.Types.Int
                   w3 :: a9 ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 Main.$wnumToBits @ a9 w ww1 w3 }) -}
198aa6a57239d095779acfbf18003617
  outVal :: Main.StreamCounter a -> GHC.Types.Int
  RecSel Main.StreamCounter
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a9 ds :: Main.StreamCounter a9 ->
                 case ds of wild { Main.StreamCounter ds1 ds2 ds3 -> ds3 }) -}
5ca6c8fb3a4b80aab2ae784328a7f5a6
  rleCount :: Main.LutEntry -> GHC.Word.Word8
  RecSel Main.LutEntry
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U(U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.LutEntry ->
                 case ds of wild { Main.LutEntry ds1 ds2 ds3 -> ds2 }) -}
31a5a2f41dbf56cfb4912452fb632566
  rleData :: Main.LutEntry -> GHC.Word.Word8
  RecSel Main.LutEntry
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.LutEntry ->
                 case ds of wild { Main.LutEntry ds1 ds2 ds3 -> ds3 }) -}
5b0bb20b549bb8f58a89d97f07d21eca
  serialize ::
    Main.EncodeDictionary -> [Main.RleEntry] -> [GHC.Types.Bool]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ dict :: Main.EncodeDictionary
                   eta :: [Main.RleEntry] ->
                 letrec {
                   go2 :: [Main.RleEntry] -> [GHC.Types.Bool]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [Main.RleEntry] ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Bool
                       : y ys
                       -> case y of wild1 { Main.Code l v ->
                          case Main.$wpoly_go10 @ [GHC.Types.Bool] l v dict of wild2 {
                            GHC.Base.Nothing
                            -> GHC.Base.++
                                 @ GHC.Types.Bool
                                 Main.serialize1
                                 (GHC.Enum.efdtIntDnFB
                                    @ [GHC.Types.Bool]
                                    (\ x :: GHC.Types.Int ys1 :: [GHC.Types.Bool][OneShot] ->
                                     GHC.Types.:
                                       @ GHC.Types.Bool
                                       (case l of wild3 { GHC.Types.I# x# ->
                                        case x of wild4 { GHC.Types.I# i# ->
                                        case GHC.Prim.tagToEnum#
                                               @ GHC.Types.Bool
                                               (GHC.Prim.>=# i# 64) of wild5 {
                                          GHC.Types.False
                                          -> case GHC.Prim.andI#
                                                    x#
                                                    (GHC.Prim.uncheckedIShiftL# 1 i#) of wild6 {
                                               DEFAULT -> GHC.Types.True 0 -> GHC.Types.False }
                                          GHC.Types.True -> GHC.Types.False } } })
                                       ys1)
                                    (GHC.Enum.efdtIntDnFB
                                       @ [GHC.Types.Bool]
                                       (\ x :: GHC.Types.Int ys1 :: [GHC.Types.Bool][OneShot] ->
                                        GHC.Types.:
                                          @ GHC.Types.Bool
                                          (case v of wild3 { GHC.Word.W8# x# ->
                                           case x of wild4 { GHC.Types.I# i# ->
                                           case GHC.Prim.tagToEnum#
                                                  @ GHC.Types.Bool
                                                  (GHC.Prim.>=# i# 64) of wild5 {
                                             GHC.Types.False
                                             -> case GHC.Prim.and#
                                                       x#
                                                       (GHC.Prim.narrow8Word#
                                                          (GHC.Prim.uncheckedShiftL#
                                                             __word 1
                                                             i#)) of wild6 {
                                                  DEFAULT -> GHC.Types.True
                                                  __word 0 -> GHC.Types.False }
                                             GHC.Types.True -> GHC.Types.False } } })
                                          ys1)
                                       (go2 ys)
                                       3
                                       2
                                       0)
                                    2
                                    1
                                    0)
                            GHC.Base.Just code
                            -> GHC.Base.++ @ GHC.Types.Bool code (go2 ys) } } }
                 } in
                 go2 eta) -}
a9cc4a5ef9624fc0bd1681387cbde828
  serialize1 :: [GHC.Types.Bool]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Bool
                   GHC.Types.True
                   Main.serialize2) -}
ac1313472c0e6f5d1d1bc0f120e0553a
  serialize2 :: [GHC.Types.Bool]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Bool
                   GHC.Types.True
                   Main.serialize3) -}
d16fa79704c47821764796e8ee71fb0c
  serialize3 :: [GHC.Types.Bool]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Bool
                   GHC.Types.True
                   Main.serialize4) -}
f6188a41471709f1cc381c2aac06c6a1
  serialize4 :: [GHC.Types.Bool]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Bool
                   GHC.Types.True
                   Main.serialize5) -}
794e56c2c39794942d6472d8cf53a887
  serialize5 :: [GHC.Types.Bool]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Bool
                   GHC.Types.True
                   Main.serialize6) -}
a2e17f76b2fe4cb9b437442a165b098d
  serialize6 :: [GHC.Types.Bool]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Bool
                   GHC.Types.True
                   (GHC.Types.[] @ GHC.Types.Bool)) -}
cc71697d04a5ad372c04e2cc00aa46fa
  serializeLutMap :: Main.LutMap -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ m :: Main.LutMap ->
                 Main.serializeLutMap_serializeMap
                   Main.serializeLutMap2
                   (Data.OldList.sortBy
                      @ (GHC.Word.Word8, Main.LutEntry)
                      Main.serializeLutMap1
                      (GHC.Base.build
                         @ (GHC.Word.Word8, Main.LutEntry)
                         (\ @ b
                            c :: (GHC.Word.Word8, Main.LutEntry) -> b -> b[OneShot]
                            n :: b[OneShot] ->
                          Data.Map.Base.foldrFB
                            @ GHC.Word.Word8
                            @ Main.LutEntry
                            @ b
                            (\ k1 :: GHC.Word.Word8
                               x :: Main.LutEntry[OneShot]
                               xs :: b[OneShot] ->
                             c (k1, x) xs)
                            n
                            m)))) -}
9afdd684b1e6840a1b9f53c32432595b
  serializeLutMap1 ::
    (GHC.Word.Word8, Main.LutEntry)
    -> (GHC.Word.Word8, Main.LutEntry) -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(LLS)),1*U(A,1*U(A,A,1*U(U)))><S(LS(LLS)),1*U(A,1*U(A,A,1*U(U)))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: (GHC.Word.Word8, Main.LutEntry)
                   w1 :: (GHC.Word.Word8, Main.LutEntry) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww2 of ww3 { Main.LutEntry ww4 ww5 ww6 ->
                 case ww6 of ww7 { GHC.Word.W8# ww8 ->
                 case w1 of ww9 { (,) ww10 ww11 ->
                 case ww11 of ww12 { Main.LutEntry ww13 ww14 ww15 ->
                 case ww15 of ww16 { GHC.Word.W8# ww17 ->
                 Main.$wlvl ww8 ww17 } } } } } }) -}
23f84557921e2a0619c576ba043ad80e
  serializeLutMap2 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 255) -}
f9a0a1ce93fb381d5137ab6e9ef14d85
  serializeLutMap_serializeMap ::
    GHC.Word.Word8
    -> [(GHC.Word.Word8, Main.LutEntry)] -> [GHC.Word.Word8]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Word.Word8 w1 :: [(GHC.Word.Word8, Main.LutEntry)] ->
                 case Main.$wserializeMap w w1 of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ GHC.Word.Word8 ww1 ww2 }) -}
e3afad637ca09bfccb4eea9c1265e0ef
  splitNybbles :: [GHC.Word.Word8] -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (Main.$sconcatMap
                   @ GHC.Word.Word8
                   @ GHC.Word.Word8
                   Main.splitNybbles1) -}
707f192cdf40cb5945511e45629bb08a
  splitNybbles1 :: GHC.Word.Word8 -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U)>m2,
     Unfolding: InlineRule (1, True, False)
                (\ x :: GHC.Word.Word8 ->
                 GHC.Types.:
                   @ GHC.Word.Word8
                   (case x of wild { GHC.Word.W8# x# ->
                    GHC.Word.W8# (GHC.Prim.uncheckedShiftRL# x# 4) })
                   (GHC.Types.:
                      @ GHC.Word.Word8
                      (case x of wild { GHC.Word.W8# x# ->
                       GHC.Word.W8# (GHC.Prim.and# x# __word 15) })
                      (GHC.Types.[] @ GHC.Word.Word8))) -}
baba60038ae6e5d4d837efbc54ae9d14
  stream :: Main.StreamCounter a -> [a]
  RecSel Main.StreamCounter
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a9 ds :: Main.StreamCounter a9 ->
                 case ds of wild { Main.StreamCounter ds1 ds2 ds3 -> ds1 }) -}
d1c9295f9c7799e1d448163bef341b80
  toBitStream ::
    [GHC.Types.Bool]
    -> Data.Bitstream.Lazy.Bitstream Data.Bitstream.Packet.Right
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: [GHC.Types.Bool] ->
                 Main.toBitStream_f
                   (Data.Vector.Fusion.Stream.$sfromList @ GHC.Types.Bool x)) -}
314012353eb81f70bf5661bb816c3dab
  toBitStream_f ::
    Data.Vector.Fusion.Stream.Stream GHC.Types.Bool
    -> Data.Bitstream.Lazy.Bitstream Data.Bitstream.Packet.Right
  {- Unfolding: (Data.Bitstream.Generic.unstream
                   @ (Data.Bitstream.Lazy.Bitstream Data.Bitstream.Packet.Right)
                   Data.Bitstream.Lazy.$fBitstreamBitstream) -}
42c610dd51dcefe9b737bb3d282ea529
  toBoolStream ::
    Data.ByteString.Lazy.Internal.ByteString -> [GHC.Types.Bool]
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ inputString :: Data.ByteString.Lazy.Internal.ByteString ->
                 case Main.toBoolStream_g
                        (Data.Bitstream.Lazy.$fBitstreamBitstream_$sfromChunks
                           (GHC.Base.map
                              @ Data.ByteString.Internal.ByteString
                              @ (Data.Bitstream.Bitstream Data.Bitstream.Packet.Right)
                              (Data.Bitstream.fromByteString @ Data.Bitstream.Packet.Right)
                              (Data.ByteString.Lazy.toChunks_go1
                                 inputString))) of wild { Data.Vector.Fusion.Stream.Monadic.Stream s00 step s1 ds1 ->
                 letrec {
                   go2 :: s00 -> [GHC.Types.Bool] {- Arity: 1, Strictness: <L,U> -}
                   = \ s2 :: s00 ->
                     case (step s2)
                            `cast`
                          (Data.Vector.Fusion.Util.NTCo:Id[0]
                               <Data.Vector.Fusion.Stream.Monadic.Step
                                  s00 GHC.Types.Bool>_R) of wild1 {
                       Data.Vector.Fusion.Stream.Monadic.Yield x1 s'
                       -> GHC.Types.: @ GHC.Types.Bool x1 (go2 s')
                       Data.Vector.Fusion.Stream.Monadic.Skip s' -> go2 s'
                       Data.Vector.Fusion.Stream.Monadic.Done
                       -> GHC.Types.[] @ GHC.Types.Bool }
                 } in
                 go2 s1 }) -}
79b328ebae9a406cc94a687c3dfc22fd
  toBoolStream_g ::
    Data.Bitstream.Lazy.Bitstream Data.Bitstream.Packet.Right
    -> Data.Vector.Fusion.Stream.Stream GHC.Types.Bool
  {- Unfolding: (Data.Bitstream.Generic.stream
                   @ (Data.Bitstream.Lazy.Bitstream Data.Bitstream.Packet.Right)
                   Data.Bitstream.Lazy.$fBitstreamBitstream) -}
6deb6f7eca2e5ebe93898c518a50db66
  trimRlesLen :: [Main.RleEntry] -> [Main.RleEntry]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (Main.$sconcatMap
                   @ Main.RleEntry
                   @ Main.RleEntry
                   Main.trimRlesLen_trimRleLen) -}
3420378aac540cecf0c97477a9ba9bc3
  trimRlesLen_trimRleLen :: Main.RleEntry -> [Main.RleEntry]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(U(U),U)>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case Main.$wtrimRleLen ww4 ww2 of ww5 { (#,#) ww6 ww7 ->
                 GHC.Types.: @ Main.RleEntry ww6 ww7 } } }) -}
3a91738e307e2b39cf01a0ca6151d1aa
  val :: Main.RleEntry -> GHC.Word.Word8
  RecSel Main.RleEntry
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.RleEntry ->
                 case ds of wild { Main.Code ds1 ds2 -> ds2 }) -}
b767f5fadaa442456e24b8dfb6095400
  xorDecrypt :: [GHC.Word.Word8] -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ xs :: [GHC.Word.Word8] ->
                 case Data.List.Split.Internals.chunksOf
                        @ GHC.Word.Word8
                        Main.xorDecrypt2
                        xs of wild {
                   [] -> GHC.Types.[] @ GHC.Word.Word8
                   : x xs1
                   -> Main.xorDecrypt_go
                        (GHC.Types.:
                           @ [GHC.Word.Word8]
                           x
                           (case GHC.List.$wscanlGo
                                   @ [GHC.Word.Word8]
                                   @ [GHC.Word.Word8]
                                   @ [GHC.Word.Word8]
                                   @ [GHC.Word.Word8]
                                   Main.xorDecrypt1
                                   x
                                   xs1 of ww { (#,#) ww1 ww2 ->
                            ww2 })) }) -}
402a6b3705bdd3990340a5c33f1ba8c6
  xorDecrypt1 ::
    [GHC.Word.Word8] -> [GHC.Word.Word8] -> [GHC.Word.Word8]
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (GHC.List.zipWith
                   @ GHC.Word.Word8
                   @ GHC.Word.Word8
                   @ GHC.Word.Word8
                   GHC.Word.$fBitsWord8_$cxor) -}
468be8da0f393970f1e278731ac0a627
  xorDecrypt2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 4) -}
8baae8c80a51e61beb9e06bcb3a65486
  xorDecrypt_go :: [[GHC.Word.Word8]] -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
f0442ff3e924e8ddab97019d06cb4b2f
  xorEncrypt :: [GHC.Word.Word8] -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ xs :: [GHC.Word.Word8] ->
                 let {
                   plain :: [[GHC.Word.Word8]]
                   = Data.List.Split.Internals.chunksOf
                       @ GHC.Word.Word8
                       Main.xorDecrypt2
                       xs
                 } in
                 Main.xorEncrypt_go
                   plain
                   (GHC.Types.: @ [GHC.Word.Word8] Main.xorEncrypt1 plain)) -}
8c93820bdd7ada85df25c68d3535ff88
  xorEncrypt1 :: [GHC.Word.Word8]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Word.Word8
                   Main.bitsToNum1
                   Main.xorEncrypt2) -}
c72338408cf9540a0e136e7db4684863
  xorEncrypt2 :: [GHC.Word.Word8]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Word.Word8
                   Main.bitsToNum1
                   Main.xorEncrypt3) -}
1ad99051a89722b20956d89f4ede0d3f
  xorEncrypt3 :: [GHC.Word.Word8]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Word.Word8
                   Main.bitsToNum1
                   Main.xorEncrypt4) -}
afb44fcc2dc90af71cb0762efbc16a4f
  xorEncrypt4 :: [GHC.Word.Word8]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Word.Word8
                   Main.bitsToNum1
                   (GHC.Types.[] @ GHC.Word.Word8)) -}
3bcf5162c58b981259c3548a1945713a
  xorEncrypt_go ::
    [[GHC.Word.Word8]] -> [[GHC.Word.Word8]] -> [GHC.Word.Word8]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
instance GHC.Classes.Eq [Main.RleEntry] = Main.$fEqRleEntry
instance GHC.Classes.Ord [Main.RleEntry] = Main.$fOrdRleEntry
instance GHC.Show.Show [Main.LutEntry] = Main.$fShowLutEntry
instance GHC.Show.Show [Main.RleEntry] = Main.$fShowRleEntry
"SPEC/Main concatMap _ _ @ []" [ALWAYS] forall @ a9
                                               @ b
                                               $dFoldable :: Data.Foldable.Foldable []
  Data.Foldable.concatMap @ a9 @ b @ [] $dFoldable
  = Main.$sconcatMap @ a9 @ b
"SPEC/Main fromListWithKey @ RleEntry _" [ALWAYS] forall @ a9
                                                         $dOrd :: GHC.Classes.Ord Main.RleEntry
  Data.Map.Strict.fromListWithKey @ Main.RleEntry @ a9 $dOrd
  = Main.$sfromListWith_$sfromListWithKey @ a9
"SPEC/Main pack @ (Bitstream Right)" [ALWAYS] forall $dBitstream :: Data.Bitstream.Generic.Bitstream
                                                                      (Data.Bitstream.Lazy.Bitstream
                                                                         Data.Bitstream.Packet.Right)
  Data.Bitstream.Generic.pack @ (Data.Bitstream.Lazy.Bitstream
                                   Data.Bitstream.Packet.Right)
                              $dBitstream
  = Main.$spack
"SPEC/Main toByteString @ Right" [ALWAYS] forall $dBitstream :: Data.Bitstream.Generic.Bitstream
                                                                  (Data.Bitstream.Bitstream
                                                                     Data.Bitstream.Packet.Right)
                                                 $dBitstream1 :: Data.Bitstream.Generic.Bitstream
                                                                   (Data.Bitstream.Packet.Packet
                                                                      Data.Bitstream.Packet.Right)
  Data.Bitstream.toByteString @ Data.Bitstream.Packet.Right
                              $dBitstream
                              $dBitstream1
  = Main.$stoByteString
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

