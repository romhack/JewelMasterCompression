
==================== FINAL INTERFACE ====================
2016-05-12 07:19:08.1713345 UTC

interface main@main:Main 7103
  interface hash: caee66eb8a9c660577cd18839a53b30c
  ABI hash: 22e16b2c6cf738f3673e7bd3d56c5886
  export-list hash: 27965eb6d9c8cb819cbc7c8e32766369
  orphan hash: 745c9a4da8f7bf4560360d8c1a5f1bda
  flag hash: 989d7567c2a4235d3a2ce5e5716544db
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.bitsToNum
  Main.buildLutMapEncode
  Main.decode
  Main.deserialize
  Main.encode
  Main.fillLut
  Main.getProbability
  Main.gfxEncodedOffset
  Main.gfxSizeOffset
  Main.histToLutEntry
  Main.histogram
  Main.lutEncodedOffset
  Main.lutEntriesCount
  Main.main
  Main.mergeNybbles
  Main.roundToPower2
  Main.splitNybbles
  Main.takeSignificantEntries
  Main.toBoolStream
  Main.trimRlesLen
  Main.xorDecrypt
  Main.xorEncrypt
  Main.LutEntry{Main.LutEntry Main.bitLen Main.rleCount Main.rleData}
  Main.LutMap
  Main.LutMapEncode
  Main.RleEntry{Main.Code Main.len Main.val}
module dependencies:
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0
                      base-unicode-symbols-0.2.2.4@baseu_HARyL3klEFABQ7g2MPHMdz
                      binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi
                      bitstream-0.2.0.4@bitst_BQbLuh1SAyZJZAeLVOmcbb
                      bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6
                      containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 primitive-0.6.1.0@primi_EphY2c7CCxSCBKjAN0YTR3
                      split-0.2.3@split_CDzOynTh4l8Ahg1HaWUL4Z
                      transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF
                      vector-0.10.12.3@vecto_Hlsuo0rfZGxDZa3vCL7yzy
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
         transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF:Control.Monad.Trans.Error
         vector-0.10.12.3@vecto_Hlsuo0rfZGxDZa3vCL7yzy:Data.Vector.Fusion.Stream
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
                         primitive-0.6.1.0@primi_EphY2c7CCxSCBKjAN0YTR3:Control.Monad.Primitive
                         vector-0.10.12.3@vecto_Hlsuo0rfZGxDZa3vCL7yzy:Data.Vector.Storable
import  -/  base-4.8.2.0:Data.Bits 87f514c5f0e66e224843da33c04aa38b
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:Data.Word ec8deb535202352cc8b509b14004bcbd
import  -/  base-4.8.2.0:GHC.Base a4939789b2cfd60b36ed163e56a623cd
import  -/  base-4.8.2.0:GHC.Float e532d434ec2447d809887c0fca1d78a5
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:GHC.Word 10dc88543d98000abab9695a1019767d
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:System.IO 638c10c4fd4901a0aca5b77c9f14123d
import  -/  binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi:Data.Binary.Get f87c878c97e7480a92e049b12d3a9019
import  -/  bitstream-0.2.0.4@bitst_BQbLuh1SAyZJZAeLVOmcbb:Data.Bitstream.Generic 39a6b796feff3070e35ab70db4d7b386
import  -/  bitstream-0.2.0.4@bitst_BQbLuh1SAyZJZAeLVOmcbb:Data.Bitstream.Lazy 40fc5880692d139a37dde6f8a6e58b25
import  -/  bitstream-0.2.0.4@bitst_BQbLuh1SAyZJZAeLVOmcbb:Data.Bitstream.Packet 45e0b91d5eba71b4ab323d748f0ddded
import  -/  bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString.Lazy 59e7973423198e93620da16e5f7527dd
import  -/  bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString.Lazy.Internal be8c2313b6f0cc8907d9784ae8e9c59d
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base 0e2fa197eb6e9c9e1e1de95c3768f6ec
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Strict 835c6fadc5446acd8356b2317fd91a15
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  split-0.2.3@split_CDzOynTh4l8Ahg1HaWUL4Z:Data.List.Split 0ce5c537605fc9ad887ec02865b54394
import  -/  split-0.2.3@split_CDzOynTh4l8Ahg1HaWUL4Z:Data.List.Split.Internals 4ea5a9e5367ae0648c6ecbbc653cbd5b
d25bbb201a36081832b287359b3b9c09
  $fEqRleEntry :: GHC.Classes.Eq Main.RleEntry
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.RleEntry Main.$fEqRleEntry_$c== Main.$fEqRleEntry_$c/= -}
d25bbb201a36081832b287359b3b9c09
  $fEqRleEntry_$c/= ::
    Main.RleEntry -> Main.RleEntry -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U(U))><S(SL),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.RleEntry w1 :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Main.Code ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Main.$w$c/= ww4 ww2 ww9 ww7 } } } }) -}
d25bbb201a36081832b287359b3b9c09
  $fEqRleEntry_$c== ::
    Main.RleEntry -> Main.RleEntry -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U(U))><S(SL),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.RleEntry w1 :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Main.Code ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Main.$w$c== ww4 ww2 ww9 ww7 } } } }) -}
d25bbb201a36081832b287359b3b9c09
  $fOrdRleEntry :: GHC.Classes.Ord Main.RleEntry
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.RleEntry
                  Main.$fEqRleEntry
                  Main.$fOrdRleEntry_$ccompare
                  Main.$fOrdRleEntry_$c<
                  Main.$fOrdRleEntry_$c<=
                  Main.$fOrdRleEntry_$c>
                  Main.$fOrdRleEntry_$c>=
                  Main.$fOrdRleEntry_$cmax
                  Main.$fOrdRleEntry_$cmin -}
d25bbb201a36081832b287359b3b9c09
  $fOrdRleEntry_$c< ::
    Main.RleEntry -> Main.RleEntry -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U(U))><S(SL),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.RleEntry w1 :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Main.Code ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Main.$w$c< ww4 ww2 ww9 ww7 } } } }) -}
d25bbb201a36081832b287359b3b9c09
  $fOrdRleEntry_$c<= ::
    Main.RleEntry -> Main.RleEntry -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U(U))><S(SL),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.RleEntry w1 :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Main.Code ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Main.$w$c<= ww4 ww2 ww9 ww7 } } } }) -}
d25bbb201a36081832b287359b3b9c09
  $fOrdRleEntry_$c> ::
    Main.RleEntry -> Main.RleEntry -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U(U))><S(SL),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.RleEntry w1 :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Main.Code ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Main.$w$c> ww4 ww2 ww9 ww7 } } } }) -}
d25bbb201a36081832b287359b3b9c09
  $fOrdRleEntry_$c>= ::
    Main.RleEntry -> Main.RleEntry -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U(U))><S(SL),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.RleEntry w1 :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Main.Code ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Main.$w$c>= ww4 ww2 ww9 ww7 } } } }) -}
d25bbb201a36081832b287359b3b9c09
  $fOrdRleEntry_$ccompare ::
    Main.RleEntry -> Main.RleEntry -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U(U))><S(SL),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.RleEntry w1 :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Main.Code ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Main.$w$ccompare ww4 ww2 ww9 ww7 } } } }) -}
d25bbb201a36081832b287359b3b9c09
  $fOrdRleEntry_$cmax ::
    Main.RleEntry -> Main.RleEntry -> Main.RleEntry
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(U(U),U(U))><S(SL),1*U(U(U),U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.RleEntry w1 :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Main.Code ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww4 ww9) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww4 ww9) of wild1 {
                        GHC.Types.False -> Main.Code (GHC.Types.I# ww4) ww2
                        GHC.Types.True
                        -> case ww2 of wild2 { GHC.Word.W8# a1 ->
                           case ww7 of wild3 { GHC.Word.W8# b1 ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.leWord# a1 b1) of wild4 {
                             GHC.Types.False -> Main.Code (GHC.Types.I# ww4) wild2
                             GHC.Types.True -> Main.Code (GHC.Types.I# ww9) wild3 } } } }
                   GHC.Types.True -> Main.Code (GHC.Types.I# ww9) ww7 } } } } }) -}
d25bbb201a36081832b287359b3b9c09
  $fOrdRleEntry_$cmin ::
    Main.RleEntry -> Main.RleEntry -> Main.RleEntry
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(U(U),U(U))><S(SL),1*U(U(U),U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.RleEntry w1 :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Main.Code ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww4 ww9) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww4 ww9) of wild1 {
                        GHC.Types.False -> Main.Code (GHC.Types.I# ww9) ww7
                        GHC.Types.True
                        -> case ww2 of wild2 { GHC.Word.W8# a1 ->
                           case ww7 of wild3 { GHC.Word.W8# b1 ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.leWord# a1 b1) of wild4 {
                             GHC.Types.False -> Main.Code (GHC.Types.I# ww9) wild3
                             GHC.Types.True -> Main.Code (GHC.Types.I# ww4) wild2 } } } }
                   GHC.Types.True -> Main.Code (GHC.Types.I# ww4) ww2 } } } } }) -}
4ce99a07c18d78ddfad825ae77e37759
  $fShowLutEntry :: GHC.Show.Show Main.LutEntry
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.LutEntry
                  Main.$fShowLutEntry_$cshowsPrec
                  Main.$fShowLutEntry_$cshow
                  Main.$fShowLutEntry_$cshowList -}
4ce99a07c18d78ddfad825ae77e37759
  $fShowLutEntry1 :: Main.LutEntry -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Main.LutEntry w1 :: GHC.Base.String ->
                 case w of ww { Main.LutEntry ww1 ww2 ww3 ->
                 Main.$w$cshowsPrec 0 ww1 ww2 ww3 w1 }) -}
864e22ac290c470fe81a6762d814d0c7
  $fShowLutEntry2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
9b29ce10f7bfc2714b9feb51aca0f9ea
  $fShowLutEntry3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "rleData = "#) -}
19b777c01a0feb9ca60f2ae81d7a2913
  $fShowLutEntry4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "rleCount = "#) -}
04df27a9f3eacc3c6dce83db21991117
  $fShowLutEntry5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
5ce36792c0f9a3503322d05e44b582d1
  $fShowLutEntry6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "bitLen = "#) -}
b1133da842de50a72fb6e7378106e69e
  $fShowLutEntry7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LutEntry {"#) -}
4ce99a07c18d78ddfad825ae77e37759
  $fShowLutEntry_$cshow :: Main.LutEntry -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(U),1*U(U),1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Main.LutEntry ->
                 Main.$fShowLutEntry_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
4ce99a07c18d78ddfad825ae77e37759
  $fShowLutEntry_$cshowList :: [Main.LutEntry] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Main.LutEntry
                   Main.$fShowLutEntry1) -}
4ce99a07c18d78ddfad825ae77e37759
  $fShowLutEntry_$cshowsPrec ::
    GHC.Types.Int -> Main.LutEntry -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <S,1*U(U)><S,1*U(1*U(U),1*U(U),1*U(U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Main.LutEntry w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Main.LutEntry ww3 ww4 ww5 ->
                 Main.$w$cshowsPrec ww1 ww3 ww4 ww5 w2 } }) -}
d25bbb201a36081832b287359b3b9c09
  $fShowRleEntry :: GHC.Show.Show Main.RleEntry
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.RleEntry
                  Main.$fShowRleEntry_$cshowsPrec
                  Main.$fShowRleEntry_$cshow
                  Main.$fShowRleEntry_$cshowList -}
d25bbb201a36081832b287359b3b9c09
  $fShowRleEntry1 :: Main.RleEntry -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Main.RleEntry w1 :: GHC.Base.String ->
                 case w of ww { Main.Code ww1 ww2 ->
                 Main.$w$cshowsPrec1 0 ww1 ww2 w1 }) -}
5ed04ce684b10ac13101118f65de4d30
  $fShowRleEntry2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Code {"#) -}
781f140e12c7569279a199eb7ff0f347
  $fShowRleEntry3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "val = "#) -}
40c128be78292b1a4a35d686bd56b0f2
  $fShowRleEntry4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "len = "#) -}
d25bbb201a36081832b287359b3b9c09
  $fShowRleEntry_$cshow :: Main.RleEntry -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(U),1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Main.RleEntry ->
                 Main.$fShowRleEntry_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d25bbb201a36081832b287359b3b9c09
  $fShowRleEntry_$cshowList :: [Main.RleEntry] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Main.RleEntry
                   Main.$fShowRleEntry1) -}
d25bbb201a36081832b287359b3b9c09
  $fShowRleEntry_$cshowsPrec ::
    GHC.Types.Int -> Main.RleEntry -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U(U),1*U(U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Main.RleEntry w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Main.Code ww3 ww4 ->
                 Main.$w$cshowsPrec1 ww1 ww3 ww4 w2 } }) -}
63f570632948f8ec01c0d1dff1553fc7
  $s^3 :: GHC.Types.Int
  {- Strictness: b -}
eae245ebc21f9837b2bc94b8da365834
  $s^4 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 0) -}
90459481fda040012954465f4b8392c9
  $sconcatMap :: (a3 -> [b]) -> [a3] -> [b]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a3 @ b f :: a3 -> [b] xs :: [a3] ->
                 GHC.Base.build
                   @ b
                   (\ @ b1 c :: b -> b1 -> b1[OneShot] n :: b1[OneShot] ->
                    GHC.Base.foldr
                      @ a3
                      @ b1
                      (\ x :: a3 b2 :: b1[OneShot] -> GHC.Base.foldr @ b @ b1 c b2 (f x))
                      n
                      xs)) -}
dabfc30d290e290d1c8d9d06916e714f
  $sfromListWith_$sfromListWithKey ::
    (Main.RleEntry -> a -> a -> a)
    -> [(Main.RleEntry, a)] -> Data.Map.Base.Map Main.RleEntry a
  {- Arity: 2, Strictness: <L,C(C1(C1(U)))><S,1*U>,
     Unfolding: (\ @ a
                   f :: Main.RleEntry -> a -> a -> a
                   xs :: [(Main.RleEntry, a)] ->
                 letrec {
                   go4 :: Data.Map.Base.Map Main.RleEntry a
                          -> [(Main.RleEntry, a)] -> Data.Map.Base.Map Main.RleEntry a
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ z :: Data.Map.Base.Map Main.RleEntry a
                       ds :: [(Main.RleEntry, a)] ->
                     case ds of wild {
                       [] -> z
                       : x xs1
                       -> case x of wild1 { (,) k1 x1 ->
                          case k1 of ww { Main.Code ww1 ww2 ->
                          case Main.$w$sgo4 @ a f ww1 ww2 x1 z of z' { DEFAULT ->
                          go4 z' xs1 } } } }
                 } in
                 go4 (Data.Map.Base.Tip @ Main.RleEntry @ a) xs) -}
2f02372a4bcc91ee8eaf27cdf9689749
  $w$c/= ::
    GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Word.Word8
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Word.Word8 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Word.W8# a1 ->
                      case ww3 of wild2 { GHC.Word.W8# b1 ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# a1 b1) of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
3ff78991e2e104b9199c1f704a2f16b0
  $w$c< ::
    GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Word.Word8
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Word.Word8 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww ww2) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww ww2) of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> GHC.Word.$fOrdWord8_$c< ww1 ww3 }
                   GHC.Types.True -> GHC.Types.True }) -}
29b8259a908ccfa25d262a6e0c8ec522
  $w$c<= ::
    GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Word.Word8
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Word.Word8 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww ww2) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww ww2) of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> GHC.Word.$fOrdWord8_$c<= ww1 ww3 }
                   GHC.Types.True -> GHC.Types.True }) -}
68582b1f1f5f83fbfb0e178504e4ebbd
  $w$c== ::
    GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Word.Word8
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Word.Word8 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> GHC.Word.$fEqWord8_$c== ww1 ww3 }) -}
c02802f3f4659e60560123b74726d71b
  $w$c> ::
    GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Word.Word8
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Word.Word8 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww ww2) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww ww2) of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Word.$fOrdWord8_$c> ww1 ww3 }
                   GHC.Types.True -> GHC.Types.False }) -}
1f8874cf404d2367f352098589698f05
  $w$c>= ::
    GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Word.Word8
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Word.Word8 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww ww2) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww ww2) of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Word.$fOrdWord8_$c>= ww1 ww3 }
                   GHC.Types.True -> GHC.Types.False }) -}
748b66b87894d69ddf9d5dd5dc35964c
  $w$ccompare ::
    GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Types.Ordering
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Word.Word8
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Word.Word8 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww ww2) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww ww2) of wild1 {
                        GHC.Types.False -> GHC.Types.GT
                        GHC.Types.True -> GHC.Word.$fOrdWord8_$ccompare ww1 ww3 }
                   GHC.Types.True -> GHC.Types.LT }) -}
0ec77880343d5ce843630dd794f15821
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> GHC.Word.Word8
    -> GHC.Word.Word8
    -> GHC.Word.Word8
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 5, Strictness: <L,U><L,1*U(U)><L,1*U(U)><L,1*U(U)><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Word.Word8
                   ww2 :: GHC.Word.Word8
                   ww3 :: GHC.Word.Word8
                   w :: GHC.Base.String ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Main.$fShowLutEntry7
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Main.$fShowLutEntry6
                          (case ww1 of wild { GHC.Word.W8# x# ->
                           let {
                             ww4 :: GHC.Prim.Int# = GHC.Prim.word2Int# x#
                           } in
                           let {
                             w1 :: GHC.Base.String
                             = GHC.Base.++
                                 @ GHC.Types.Char
                                 Main.$fShowLutEntry5
                                 (GHC.Base.++
                                    @ GHC.Types.Char
                                    Main.$fShowLutEntry4
                                    (case ww2 of wild1 { GHC.Word.W8# x#1 ->
                                     let {
                                       ww5 :: GHC.Prim.Int# = GHC.Prim.word2Int# x#1
                                     } in
                                     let {
                                       w2 :: GHC.Base.String
                                       = GHC.Base.++
                                           @ GHC.Types.Char
                                           Main.$fShowLutEntry5
                                           (GHC.Base.++
                                              @ GHC.Types.Char
                                              Main.$fShowLutEntry3
                                              (case ww3 of wild2 { GHC.Word.W8# x#2 ->
                                               let {
                                                 ww6 :: GHC.Prim.Int# = GHC.Prim.word2Int# x#2
                                               } in
                                               case GHC.Prim.tagToEnum#
                                                      @ GHC.Types.Bool
                                                      (GHC.Prim.<# ww6 0) of wild3 {
                                                 GHC.Types.False
                                                 -> case GHC.Show.$witos
                                                           ww6
                                                           (GHC.Base.++
                                                              @ GHC.Types.Char
                                                              Main.$fShowLutEntry2
                                                              x) of ww7 { (#,#) ww8 ww9 ->
                                                    GHC.Types.: @ GHC.Types.Char ww8 ww9 }
                                                 GHC.Types.True
                                                 -> case GHC.Show.$witos
                                                           ww6
                                                           (GHC.Base.++
                                                              @ GHC.Types.Char
                                                              Main.$fShowLutEntry2
                                                              x) of ww7 { (#,#) ww8 ww9 ->
                                                    GHC.Types.: @ GHC.Types.Char ww8 ww9 } } }))
                                     } in
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.<# ww5 0) of wild2 {
                                       GHC.Types.False
                                       -> case GHC.Show.$witos ww5 w2 of ww6 { (#,#) ww7 ww8 ->
                                          GHC.Types.: @ GHC.Types.Char ww7 ww8 }
                                       GHC.Types.True
                                       -> case GHC.Show.$witos ww5 w2 of ww6 { (#,#) ww7 ww8 ->
                                          GHC.Types.: @ GHC.Types.Char ww7 ww8 } } }))
                           } in
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<# ww4 0) of wild1 {
                             GHC.Types.False
                             -> case GHC.Show.$witos ww4 w1 of ww5 { (#,#) ww6 ww7 ->
                                GHC.Types.: @ GHC.Types.Char ww6 ww7 }
                             GHC.Types.True
                             -> case GHC.Show.$witos ww4 w1 of ww5 { (#,#) ww6 ww7 ->
                                GHC.Types.: @ GHC.Types.Char ww6 ww7 } } }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w)) }) -}
446af3761610d9fa0da6c4884a85e998
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Word.Word8
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><L,1*U(U)><L,1*U(U)><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Types.Int
                   ww2 :: GHC.Word.Word8
                   w :: GHC.Base.String ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Main.$fShowRleEntry4
                       (case ww1 of ww3 { GHC.Types.I# ww4 ->
                        case GHC.Show.$wshowSignedInt
                               0
                               ww4
                               (GHC.Base.++
                                  @ GHC.Types.Char
                                  Main.$fShowLutEntry5
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     Main.$fShowRleEntry3
                                     (case ww2 of wild { GHC.Word.W8# x# ->
                                      let {
                                        ww5 :: GHC.Prim.Int# = GHC.Prim.word2Int# x#
                                      } in
                                      case GHC.Prim.tagToEnum#
                                             @ GHC.Types.Bool
                                             (GHC.Prim.<# ww5 0) of wild1 {
                                        GHC.Types.False
                                        -> case GHC.Show.$witos
                                                  ww5
                                                  (GHC.Base.++
                                                     @ GHC.Types.Char
                                                     Main.$fShowLutEntry2
                                                     x) of ww6 { (#,#) ww7 ww8 ->
                                           GHC.Types.: @ GHC.Types.Char ww7 ww8 }
                                        GHC.Types.True
                                        -> case GHC.Show.$witos
                                                  ww5
                                                  (GHC.Base.++
                                                     @ GHC.Types.Char
                                                     Main.$fShowLutEntry2
                                                     x) of ww6 { (#,#) ww7 ww8 ->
                                           GHC.Types.:
                                             @ GHC.Types.Char
                                             ww7
                                             ww8 } } }))) of ww5 { (#,#) ww6 ww7 ->
                        GHC.Types.: @ GHC.Types.Char ww6 ww7 } })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++ @ GHC.Types.Char Main.$fShowRleEntry2 (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Main.$fShowRleEntry2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
07ba4259c72577e1b398fc05f48f4818
  $w$s^ :: GHC.Types.Int -> GHC.Integer.Type.Integer -> GHC.Prim.Int#
  {- Arity: 2, Strictness: <L,U(U)><S,U>, Inline: [0],
     Unfolding: (\ w :: GHC.Types.Int w1 :: GHC.Integer.Type.Integer ->
                 case GHC.Integer.Type.ltInteger# w1 Main.$s^4 of wild { DEFAULT ->
                 case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild of wild1 {
                   GHC.Types.False
                   -> case GHC.Integer.Type.eqInteger#
                             w1
                             Main.$s^4 of wild2 { DEFAULT ->
                      case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2 of wild3 {
                        GHC.Types.False
                        -> case w of ww { GHC.Types.I# ww1 -> Main.$wf1 ww1 w1 }
                        GHC.Types.True -> 1 } }
                   GHC.Types.True -> case Main.$s^3 ret_ty GHC.Prim.Int# of {} } }) -}
30452e7d5e0c6eef88f636f4f1ce63af
  $w$sgo1 ::
    GHC.Prim.Word#
    -> a1
    -> Data.Map.Base.Map GHC.Word.Word8 a1
    -> Data.Map.Base.Map GHC.Word.Word8 a1
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>, Inline: [0] -}
0371537158ae3d79d6e3ec217c51a36b
  $w$sgo4 ::
    (Main.RleEntry -> a1 -> a1 -> a1)
    -> GHC.Types.Int
    -> GHC.Word.Word8
    -> a1
    -> Data.Map.Base.Map Main.RleEntry a1
    -> Data.Map.Base.Map Main.RleEntry a1
  {- Arity: 5,
     Strictness: <L,1*C1(C1(C1(U)))><L,U(U)><L,U(U)><L,U><S,1*U>,
     Inline: [0] -}
95f955fdd85066e15745309b864312df
  $wdecode :: GHC.Prim.Int# -> [Main.RleEntry] -> [GHC.Word.Word8]
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
1f3f6c07539115b3afac64353cef90f7
  $wdeserialize ::
    Main.LutMap
    -> [GHC.Types.Bool] -> (# Main.RleEntry, [Main.RleEntry] #)
  {- Arity: 2, Strictness: <L,U><S,U>, Inline: [0] -}
21c36182631397a2995231027affc17e
  $wf :: GHC.Prim.Word# -> GHC.Prim.Word# -> GHC.Prim.Word#
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0] -}
f4e8a3ff12bef11f9bd94f309e24b482
  $wf1 :: GHC.Prim.Int# -> GHC.Integer.Type.Integer -> GHC.Prim.Int#
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0] -}
b57baaad6bd7d55ebc79dc0c636302cf
  $wgetProbability :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ww1 :: GHC.Prim.Int# ->
                 case GHC.Prim./##
                        (GHC.Prim.int2Double# ww)
                        (GHC.Prim.int2Double# ww1) of wild2 { DEFAULT ->
                 let {
                   x :: GHC.Prim.Double# = GHC.Prim.*## wild2 252.0
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<## x 1.0) of wild {
                   GHC.Types.False
                   -> case {__pkg_ccall base-4.8.2.0 rintDouble GHC.Prim.Double#
                                                                -> GHC.Prim.State#
                                                                     GHC.Prim.RealWorld
                                                                -> (# GHC.Prim.State#
                                                                        GHC.Prim.RealWorld,
                                                                      GHC.Prim.Double# #)}
                             x
                             GHC.Prim.realWorld# of wild1 { (#,#) ds3 ds4 ->
                      case GHC.Integer.Type.decodeDoubleInteger
                             ds4 of ds { (#,#) ipv ipv1 ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<# ipv1 0) of wild3 {
                        GHC.Types.False
                        -> case GHC.Integer.Type.leInteger#
                                  (GHC.Integer.Type.shiftLInteger ipv ipv1)
                                  Main.bitsToNum6 of wild4 { DEFAULT ->
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild4 of wild5 {
                             GHC.Types.False -> Main.$wroundToPower2 x
                             GHC.Types.True
                             -> case {__pkg_ccall base-4.8.2.0 rintDouble GHC.Prim.Double#
                                                                          -> GHC.Prim.State#
                                                                               GHC.Prim.RealWorld
                                                                          -> (# GHC.Prim.State#
                                                                                  GHC.Prim.RealWorld,
                                                                                GHC.Prim.Double# #)}
                                       x
                                       GHC.Prim.realWorld# of wild6 { (#,#) ds2 ds1 ->
                                GHC.Prim.double2Int# ds1 } } }
                        GHC.Types.True
                        -> case GHC.Integer.Type.integerToInt ipv of n { DEFAULT ->
                           case GHC.Integer.Type.leInteger#
                                  (GHC.Integer.Type.smallInteger
                                     (GHC.Prim.uncheckedIShiftRA# n (GHC.Prim.negateInt# ipv1)))
                                  Main.bitsToNum6 of wild4 { DEFAULT ->
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild4 of wild5 {
                             GHC.Types.False -> Main.$wroundToPower2 x
                             GHC.Types.True
                             -> case {__pkg_ccall base-4.8.2.0 rintDouble GHC.Prim.Double#
                                                                          -> GHC.Prim.State#
                                                                               GHC.Prim.RealWorld
                                                                          -> (# GHC.Prim.State#
                                                                                  GHC.Prim.RealWorld,
                                                                                GHC.Prim.Double# #)}
                                       x
                                       GHC.Prim.realWorld# of wild6 { (#,#) ds2 ds1 ->
                                GHC.Prim.double2Int# ds1 } } } } } } }
                   GHC.Types.True -> 0 } }) -}
8376bc902ab70c392e989482f200323a
  $wgo ::
    GHC.Prim.Int# -> [(GHC.Types.Int, a)] -> [(GHC.Types.Int, a)]
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
b8c1410f557195b36828c559763216b3
  $wpoly_goNothing ::
    GHC.Prim.Word#
    -> Data.Map.Base.Map GHC.Word.Word8 v
    -> GHC.Base.Maybe (GHC.Word.Word8, v)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>, Inline: [0] -}
8b9ad11227fbecd4f4b6398fef2eed12
  $wroundToPower2 :: GHC.Prim.Double# -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Double# ->
                 case GHC.Prim.logDouble# ww of wild2 { DEFAULT ->
                 case GHC.Prim.logDouble# 2.0 of wild3 { DEFAULT ->
                 case GHC.Prim./## wild2 wild3 of wild4 { DEFAULT ->
                 case GHC.Integer.Type.decodeDoubleInteger
                        wild4 of ds1 { (#,#) ipv ipv1 ->
                 let {
                   bitSize :: GHC.Integer.Type.Integer
                   = case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<# ipv1 0) of wild1 {
                       GHC.Types.False -> GHC.Integer.Type.shiftLInteger ipv ipv1
                       GHC.Types.True
                       -> let {
                            s :: GHC.Prim.Int# = GHC.Prim.negateInt# ipv1
                          } in
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># s 52) of wild7 {
                            GHC.Types.False
                            -> case GHC.Integer.Type.integerToInt ipv of n { DEFAULT ->
                               GHC.Integer.Type.smallInteger (GHC.Prim.uncheckedIShiftRA# n s) }
                            GHC.Types.True
                            -> case GHC.Integer.Type.ltInteger#
                                      ipv
                                      Main.$s^4 of wild { DEFAULT ->
                               case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild of wild8 {
                                 GHC.Types.False -> Main.$s^4
                                 GHC.Types.True -> Main.getProbability2 } } } }
                 } in
                 case Main.$w$s^ Main.getProbability1 bitSize of ww1 { DEFAULT ->
                 case Main.$w$s^
                        Main.getProbability1
                        (GHC.Integer.Type.plusInteger
                           bitSize
                           Main.bitsToNum5) of ww2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>##
                           (GHC.Prim.-## ww (GHC.Prim.int2Double# ww1))
                           (GHC.Prim.-## (GHC.Prim.int2Double# ww2) ww)) of wild {
                   GHC.Types.False -> ww1 GHC.Types.True -> ww2 } } } } } } }) -}
5a7714caef58796b731afad1ce69b16d
  $wtrimRleLen ::
    GHC.Prim.Int#
    -> GHC.Word.Word8 -> (# Main.RleEntry, [Main.RleEntry] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>, Inline: [0] -}
4ce99a07c18d78ddfad825ae77e37759
  data LutEntry
    = LutEntry {bitLen :: GHC.Word.Word8,
                rleCount :: GHC.Word.Word8,
                rleData :: GHC.Word.Word8}
28de308d474d6a54a7afb241415c4275
  type LutMap = Data.Map.Base.Map GHC.Word.Word8 Main.LutEntry
6bf3492ed800b4c3ed0831e61fbe446e
  type LutMapEncode = Data.Map.Base.Map Main.LutEntry GHC.Word.Word8
d25bbb201a36081832b287359b3b9c09
  data RleEntry = Code {len :: GHC.Types.Int, val :: GHC.Word.Word8}
812ca1f787543eec884d70c45f8295b9
  bitLen :: Main.LutEntry -> GHC.Word.Word8
  RecSel Main.LutEntry
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U(U),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.LutEntry ->
                 case ds of wild { Main.LutEntry ds1 ds2 ds3 -> ds1 }) -}
172c8c83126dbae9a1701f3911b8d70f
  bitsToNum :: GHC.Num.Num a => [GHC.Types.Bool] -> a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))>,
     Unfolding: (\ @ a $dNum :: GHC.Num.Num a ->
                 let {
                   lvl13 :: a = GHC.Num.fromInteger @ a $dNum Main.bitsToNum6
                 } in
                 let {
                   lvl14 :: a = GHC.Num.fromInteger @ a $dNum Main.$s^4
                 } in
                 let {
                   lvl15 :: a = GHC.Num.fromInteger @ a $dNum Main.bitsToNum5
                 } in
                 GHC.List.foldl'
                   @ GHC.Types.Bool
                   @ a
                   (\ byte :: a b :: GHC.Types.Bool[OneShot] ->
                    GHC.Num.+
                      @ a
                      $dNum
                      (GHC.Num.* @ a $dNum byte lvl13)
                      (case b of wild {
                         GHC.Types.False -> lvl14 GHC.Types.True -> lvl15 }))
                   lvl14) -}
e7565e0c6a5c117e539d53ce45d3b3f5
  bitsToNum1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 0) -}
cbc3ae2a1b21404ac2f74dae0d247eb3
  bitsToNum5 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 1) -}
4dd261cabc4519d9bd2887222ea09ca4
  bitsToNum6 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 2) -}
19a7439fa0aaf952807d2780b63faada
  buildLutMapEncode ::
    [(GHC.Types.Int, Main.RleEntry)] -> Main.LutMap
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ xs :: [(GHC.Types.Int, Main.RleEntry)] ->
                 Main.buildLutMapEncode_go
                   (GHC.Base.build
                      @ Main.LutEntry
                      (\ @ b1 c :: Main.LutEntry -> b1 -> b1[OneShot] n :: b1[OneShot] ->
                       GHC.Base.foldr
                         @ (GHC.Types.Int, Main.RleEntry)
                         @ b1
                         (GHC.Base.mapFB
                            @ Main.LutEntry
                            @ b1
                            @ (GHC.Types.Int, Main.RleEntry)
                            c
                            Main.histToLutEntry)
                         n
                         xs))
                   Main.bitsToNum1) -}
a49b2617675c14b7c2ac7f6f4184f0cb
  buildLutMapEncode_go ::
    [Main.LutEntry]
    -> GHC.Word.Word8 -> Data.Map.Base.Map GHC.Word.Word8 Main.LutEntry
  {- Arity: 2, Strictness: <S,1*U><L,1*U(U)> -}
624b3f973d1a5a798c9b685798e0bcc5
  decode :: GHC.Types.Int -> [Main.RleEntry] -> [GHC.Word.Word8]
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: [Main.RleEntry] ->
                 case w of ww { GHC.Types.I# ww1 -> Main.$wdecode ww1 w1 }) -}
a03416200dcc1b215131c6d1d650b390
  deserialize :: Main.LutMap -> [GHC.Types.Bool] -> [Main.RleEntry]
  {- Arity: 2, Strictness: <L,U><S,U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.LutMap w1 :: [GHC.Types.Bool] ->
                 case Main.$wdeserialize w w1 of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ Main.RleEntry ww1 ww2 }) -}
a778800c2ddde70df37c4439fdadc13f
  encode :: [GHC.Word.Word8] -> [Main.RleEntry]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: [GHC.Word.Word8] ->
                 GHC.Base.build
                   @ Main.RleEntry
                   (\ @ b1 c :: Main.RleEntry -> b1 -> b1[OneShot] n :: b1[OneShot] ->
                    GHC.Base.foldr
                      @ [GHC.Word.Word8]
                      @ b1
                      (GHC.Base.mapFB
                         @ Main.RleEntry
                         @ b1
                         @ [GHC.Word.Word8]
                         c
                         Main.encode1)
                      n
                      (Data.OldList.groupBy
                         @ GHC.Word.Word8
                         GHC.Word.$fEqWord8_$c==
                         x))) -}
d37c08b429bb753498f352f17a90fb2f
  encode1 :: [GHC.Word.Word8] -> Main.RleEntry
  {- Arity: 1, Strictness: <L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Word.Word8] ->
                 Main.Code
                   (case GHC.List.$wlenAcc @ GHC.Word.Word8 w 0 of ww2 { DEFAULT ->
                    GHC.Types.I# (GHC.Prim.-# ww2 1) })
                   (GHC.List.head @ GHC.Word.Word8 w)) -}
cb37a6d5067a95ed5111177a603c4284
  fillLut :: GHC.Word.Word8 -> [GHC.Word.Word8] -> Main.LutMap
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
03531c7f792f8730162dff48562e6ed7
  getProbability :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { GHC.Types.I# ww3 ->
                 case Main.$wgetProbability ww1 ww3 of ww4 { DEFAULT ->
                 GHC.Types.I# ww4 } } }) -}
6884d0ac04f5ddfe7a630e51039b70cb
  getProbability1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 2) -}
d8fd568f9fe6d103a557a3370e41851d
  getProbability2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer -1) -}
8f25e04a50d4d18df402b8b5be1666d9
  gfxEncodedOffset :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 239187) -}
c71b50a3472b8862ad4150052dde21bf
  gfxSizeOffset :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 239104) -}
1c3ea1322f4d3102f713f64a3617b278
  histToLutEntry :: (GHC.Types.Int, Main.RleEntry) -> Main.LutEntry
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS),1*U(1*U(U),1*U(1*U(U),U))>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: (GHC.Types.Int, Main.RleEntry) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww2 of ww3 { Main.Code ww4 ww5 ->
                 Main.LutEntry
                   (case ww1 of wild { GHC.Types.I# i ->
                    case GHC.Prim.logDouble#
                           (GHC.Prim.int2Double# i) of wild2 { DEFAULT ->
                    case GHC.Prim.logDouble# 2.0 of wild3 { DEFAULT ->
                    case GHC.Prim./## wild2 wild3 of wild4 { DEFAULT ->
                    case {__pkg_ccall base-4.8.2.0 rintDouble GHC.Prim.Double#
                                                              -> GHC.Prim.State# GHC.Prim.RealWorld
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Double# #)}
                           wild4
                           GHC.Prim.realWorld# of wild1 { (#,#) ds2 ds3 ->
                    GHC.Word.W8#
                      (GHC.Prim.narrow8Word#
                         (GHC.Prim.minusWord#
                            __word 8
                            (GHC.Prim.narrow8Word#
                               (GHC.Prim.int2Word# (GHC.Prim.double2Int# ds3))))) } } } } })
                   (case ww4 of wild { GHC.Types.I# x# ->
                    GHC.Word.W8# (GHC.Prim.narrow8Word# (GHC.Prim.int2Word# x#)) })
                   ww5 } }) -}
68fa1635d1334ed47941975e4b9a3da6
  histogram :: GHC.Classes.Ord a => [a] -> [(GHC.Types.Int, a)]
  {- Arity: 2, Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U>,
     Unfolding: (\ @ a $dOrd :: GHC.Classes.Ord a xs :: [a] ->
                 Main.histogram4
                   @ a
                   (GHC.Types.[] @ (GHC.Types.Int, a))
                   (Data.Map.Strict.fromListWithKey
                      @ a
                      @ GHC.Types.Int
                      $dOrd
                      (Main.histogram3 @ a)
                      (Main.histogram2 @ a xs))) -}
65a00e172f9b33b8a7eddca5897729ca
  histogram1 ::
    Main.RleEntry -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 3, HasNoCafRefs,
     Unfolding: (\ ds :: Main.RleEntry
                   x :: GHC.Types.Int[OneShot]
                   y :: GHC.Types.Int[OneShot] ->
                 GHC.Num.$fNumInt_$c+ x y) -}
409e930ce9686dc5ceef8303acbb2cc2
  histogram2 :: [a] -> [(a, GHC.Types.Int)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
88dcd73f6782fb5f346cdfa49e981486
  histogram3 :: a -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 3, HasNoCafRefs,
     Unfolding: (\ @ a
                   ds :: a
                   x :: GHC.Types.Int[OneShot]
                   y :: GHC.Types.Int[OneShot] ->
                 GHC.Num.$fNumInt_$c+ x y) -}
f1618cb434a81f38ebc874f38d3c1163
  histogram4 ::
    [(GHC.Types.Int, a)]
    -> Data.Map.Base.Map a GHC.Types.Int -> [(GHC.Types.Int, a)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U> -}
50adae762590f0cfd78e18d3e81c17b4
  histogram_go :: [Main.RleEntry] -> [(Main.RleEntry, GHC.Types.Int)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
570fe138865288d10394c4a6f1f2717a
  histogram_go10 ::
    [(GHC.Types.Int, Main.RleEntry)]
    -> Data.Map.Base.Map Main.RleEntry GHC.Types.Int
    -> [(GHC.Types.Int, Main.RleEntry)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U> -}
2b84ee2cfc18c4c3a73663b2bba64e7b
  len :: Main.RleEntry -> GHC.Types.Int
  RecSel Main.RleEntry
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.RleEntry ->
                 case ds of wild { Main.Code ds1 ds2 -> ds1 }) -}
e5cf1628bf138d84c64b48182cd2ca07
  lutEncodedOffset :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 239106) -}
b76f4249e2ec2628fcd43fcd4de94a53
  lutEntriesCount :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 252) -}
4437814b3008d02a12c3cb263637d3d4
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
ecd758eceff96e76b6b60af6eed6bbef
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.IO.Handle.FD.openBinaryFile1
                        Main.main9
                        GHC.IO.IOMode.ReadMode
                        s of ds1 { (#,#) ipv ipv1 ->
                 case Data.ByteString.Lazy.getContents2
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (let {
                      plain :: [[GHC.Word.Word8]]
                      = Data.List.Split.Internals.chunksOf
                          @ GHC.Word.Word8
                          Main.main8
                          (Data.ByteString.Lazy.Internal.unpackBytes ipv3)
                    } in
                    GHC.Show.showList__
                      @ (GHC.Types.Int, Main.RleEntry)
                      Main.main7
                      (Data.OldList.sortBy
                         @ (GHC.Types.Int, Main.RleEntry)
                         Main.main6
                         (Main.histogram_go10
                            (GHC.Types.[] @ (GHC.Types.Int, Main.RleEntry))
                            (Main.$sfromListWith_$sfromListWithKey
                               @ GHC.Types.Int
                               Main.histogram1
                               (Main.histogram_go
                                  (Main.main_go2
                                     (Data.OldList.groupBy
                                        @ GHC.Word.Word8
                                        GHC.Word.$fEqWord8_$c==
                                        (Main.main_go1
                                           (Main.main_go
                                              plain
                                              (GHC.Types.:
                                                 @ [GHC.Word.Word8]
                                                 Main.main2
                                                 plain)))))))))
                      (GHC.Types.[] @ GHC.Types.Char))
                   GHC.Types.True
                   ipv2 } }) -}
ef3c6ea0b6d6119775e2a533b50ab7c4
  main10 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R))) -}
8d7a78c27dab37cad35aa7168798dc43
  main2 :: [GHC.Word.Word8]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Word.Word8
                   Main.bitsToNum1
                   Main.main3) -}
772366dc187e37ea9c32eaea36cfe2f5
  main3 :: [GHC.Word.Word8]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Word.Word8
                   Main.bitsToNum1
                   Main.main4) -}
3753c5a3aa564f9a515775f2d47f4bb0
  main4 :: [GHC.Word.Word8]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Word.Word8
                   Main.bitsToNum1
                   Main.main5) -}
8660c93a5983022978d21b3c25224b3a
  main5 :: [GHC.Word.Word8]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Word.Word8
                   Main.bitsToNum1
                   (GHC.Types.[] @ GHC.Word.Word8)) -}
04c0b87909c08ed3860339d4f55acbb7
  main6 ::
    (GHC.Types.Int, Main.RleEntry)
    -> (GHC.Types.Int, Main.RleEntry) -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (\ x :: (GHC.Types.Int, Main.RleEntry)
                   y :: (GHC.Types.Int, Main.RleEntry)[OneShot] ->
                 case y of ww { (,) ww1 ww2 ->
                 case x of ww3 { (,) ww4 ww5 ->
                 case ww1 of wild { GHC.Types.I# x# ->
                 case ww4 of wild1 { GHC.Types.I# y# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# x# y#) of wild2 {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x# y#) of wild3 {
                        GHC.Types.False -> GHC.Types.GT
                        GHC.Types.True -> Main.$fOrdRleEntry_$ccompare ww2 ww5 }
                   GHC.Types.True -> GHC.Types.LT } } } } }) -}
2f759c489eebd05204c0207a4cc9ee2a
  main7 ::
    (GHC.Types.Int, Main.RleEntry)
    -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ w3 :: (GHC.Types.Int, Main.RleEntry)
                   w4 :: GHC.Base.String[OneShot] ->
                 case w3 of ww { (,) ww1 ww2 ->
                 GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows9
                   (case ww1 of ww4 { GHC.Types.I# ww3 ->
                    case GHC.Show.$wshowSignedInt
                           0
                           ww3
                           (GHC.Types.:
                              @ GHC.Types.Char
                              GHC.Show.showList__1
                              (GHC.Show.$fShow(,)_$sgo
                                 (\ w :: GHC.Base.String ->
                                  case ww2 of ww5 { Main.Code ww6 ww7 ->
                                  Main.$w$cshowsPrec1 0 ww6 ww7 w })
                                 (GHC.Types.[] @ GHC.Show.ShowS)
                                 (GHC.Types.:
                                    @ GHC.Types.Char
                                    GHC.Show.shows8
                                    w4))) of ww5 { (#,#) ww6 ww7 ->
                    GHC.Types.: @ GHC.Types.Char ww6 ww7 } }) }) -}
ddb847bc41592216f47a6fa5024e9fed
  main8 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 4) -}
76744bd4234951bd0e6542b2654f99a0
  main9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "decodedMaster.bin"#) -}
cec86f1795e8aec1d3d0ffd308c0e0a9
  main_go ::
    [[GHC.Word.Word8]] -> [[GHC.Word.Word8]] -> [GHC.Word.Word8]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
9956629ff746f822108c53b92e289534
  main_go1 :: [GHC.Word.Word8] -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
8974e721814868d15fec2009d23c2062
  main_go2 :: [[GHC.Word.Word8]] -> [Main.RleEntry]
  {- Arity: 1, Strictness: <S,1*U> -}
ec0243367099e8bb8d666a5d8bb38b28
  mergeNybbles :: [GHC.Word.Word8] -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
5ca6c8fb3a4b80aab2ae784328a7f5a6
  rleCount :: Main.LutEntry -> GHC.Word.Word8
  RecSel Main.LutEntry
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U(U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.LutEntry ->
                 case ds of wild { Main.LutEntry ds1 ds2 ds3 -> ds2 }) -}
31a5a2f41dbf56cfb4912452fb632566
  rleData :: Main.LutEntry -> GHC.Word.Word8
  RecSel Main.LutEntry
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.LutEntry ->
                 case ds of wild { Main.LutEntry ds1 ds2 ds3 -> ds3 }) -}
9fe1e284d2094ca96c0a6b13a9c35903
  roundToPower2 :: GHC.Types.Double -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U(U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Double ->
                 case w of ww { GHC.Types.D# ww1 ->
                 case Main.$wroundToPower2 ww1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
86234c05e253b90087d910c06d33a52a
  splitNybbles :: [GHC.Word.Word8] -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (Main.$sconcatMap
                   @ GHC.Word.Word8
                   @ GHC.Word.Word8
                   Main.splitNybbles1) -}
707f192cdf40cb5945511e45629bb08a
  splitNybbles1 :: GHC.Word.Word8 -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U)>m2,
     Unfolding: InlineRule (1, True, False)
                (\ x :: GHC.Word.Word8 ->
                 GHC.Types.:
                   @ GHC.Word.Word8
                   (case x of wild { GHC.Word.W8# x# ->
                    GHC.Word.W8# (GHC.Prim.uncheckedShiftRL# x# 4) })
                   (GHC.Types.:
                      @ GHC.Word.Word8
                      (case x of wild { GHC.Word.W8# x# ->
                       GHC.Word.W8# (GHC.Prim.and# x# __word 15) })
                      (GHC.Types.[] @ GHC.Word.Word8))) -}
213e70f048242b6871456d7753acca61
  takeSignificantEntries ::
    [(GHC.Types.Int, a)] -> [(GHC.Types.Int, a)]
  {- Arity: 1,
     Unfolding: (\ @ a w :: [(GHC.Types.Int, a)] ->
                 Main.$wgo @ a 0 w) -}
986f304cc0f75c1ad6d913882baab205
  toBoolStream ::
    Data.ByteString.Lazy.Internal.ByteString -> [GHC.Types.Bool]
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ inputString :: Data.ByteString.Lazy.Internal.ByteString ->
                 case Main.toBoolStream_g
                        (Data.Bitstream.Lazy.$fBitstreamBitstream_$sfromChunks
                           (GHC.Base.map
                              @ Data.ByteString.Internal.ByteString
                              @ (Data.Bitstream.Bitstream Data.Bitstream.Packet.Right)
                              (Data.Bitstream.fromByteString @ Data.Bitstream.Packet.Right)
                              (Data.ByteString.Lazy.toChunks_go1
                                 inputString))) of wild { Data.Vector.Fusion.Stream.Monadic.Stream s00 step s1 ds1 ->
                 letrec {
                   go :: s00 -> [GHC.Types.Bool] {- Arity: 1, Strictness: <L,U> -}
                   = \ s2 :: s00 ->
                     case (step s2)
                            `cast`
                          (Data.Vector.Fusion.Util.NTCo:Id[0]
                               <Data.Vector.Fusion.Stream.Monadic.Step
                                  s00 GHC.Types.Bool>_R) of wild1 {
                       Data.Vector.Fusion.Stream.Monadic.Yield x1 s'
                       -> GHC.Types.: @ GHC.Types.Bool x1 (go s')
                       Data.Vector.Fusion.Stream.Monadic.Skip s' -> go s'
                       Data.Vector.Fusion.Stream.Monadic.Done
                       -> GHC.Types.[] @ GHC.Types.Bool }
                 } in
                 go s1 }) -}
79b328ebae9a406cc94a687c3dfc22fd
  toBoolStream_g ::
    Data.Bitstream.Lazy.Bitstream Data.Bitstream.Packet.Right
    -> Data.Vector.Fusion.Stream.Stream GHC.Types.Bool
  {- Unfolding: (Data.Bitstream.Generic.stream
                   @ (Data.Bitstream.Lazy.Bitstream Data.Bitstream.Packet.Right)
                   Data.Bitstream.Lazy.$fBitstreamBitstream) -}
a90388062b0c770422f065067ba6b28f
  trimRlesLen :: [Main.RleEntry] -> [Main.RleEntry]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (Main.$sconcatMap
                   @ Main.RleEntry
                   @ Main.RleEntry
                   Main.trimRlesLen_trimRleLen) -}
ef40337a252d7309108e8b6411d9bb7b
  trimRlesLen_trimRleLen :: Main.RleEntry -> [Main.RleEntry]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(U(U),U)>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: Main.RleEntry ->
                 case w of ww { Main.Code ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case Main.$wtrimRleLen ww4 ww2 of ww5 { (#,#) ww6 ww7 ->
                 GHC.Types.: @ Main.RleEntry ww6 ww7 } } }) -}
794300a8da1c1fb5a70146167eeea58f
  val :: Main.RleEntry -> GHC.Word.Word8
  RecSel Main.RleEntry
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.RleEntry ->
                 case ds of wild { Main.Code ds1 ds2 -> ds2 }) -}
b871294603ed829146d8d0b8f68fcb9f
  xorDecrypt :: [GHC.Word.Word8] -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ xs :: [GHC.Word.Word8] ->
                 case Data.List.Split.Internals.chunksOf
                        @ GHC.Word.Word8
                        Main.main8
                        xs of wild {
                   [] -> GHC.Types.[] @ GHC.Word.Word8
                   : x xs1
                   -> Main.xorDecrypt_go
                        (GHC.Types.:
                           @ [GHC.Word.Word8]
                           x
                           (case GHC.List.$wscanlGo
                                   @ [GHC.Word.Word8]
                                   @ [GHC.Word.Word8]
                                   @ [GHC.Word.Word8]
                                   @ [GHC.Word.Word8]
                                   Main.xorDecrypt1
                                   x
                                   xs1 of ww { (#,#) ww1 ww2 ->
                            ww2 })) }) -}
402a6b3705bdd3990340a5c33f1ba8c6
  xorDecrypt1 ::
    [GHC.Word.Word8] -> [GHC.Word.Word8] -> [GHC.Word.Word8]
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (GHC.List.zipWith
                   @ GHC.Word.Word8
                   @ GHC.Word.Word8
                   @ GHC.Word.Word8
                   GHC.Word.$fBitsWord8_$cxor) -}
8baae8c80a51e61beb9e06bcb3a65486
  xorDecrypt_go :: [[GHC.Word.Word8]] -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
addf4822a1b3f4d9e72ca94a70e6d1fe
  xorEncrypt :: [GHC.Word.Word8] -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ xs :: [GHC.Word.Word8] ->
                 let {
                   plain :: [[GHC.Word.Word8]]
                   = Data.List.Split.Internals.chunksOf @ GHC.Word.Word8 Main.main8 xs
                 } in
                 Main.main_go
                   plain
                   (GHC.Types.: @ [GHC.Word.Word8] Main.main2 plain)) -}
instance GHC.Classes.Eq [Main.RleEntry] = Main.$fEqRleEntry
instance GHC.Classes.Ord [Main.RleEntry] = Main.$fOrdRleEntry
instance GHC.Show.Show [Main.LutEntry] = Main.$fShowLutEntry
instance GHC.Show.Show [Main.RleEntry] = Main.$fShowRleEntry
"SPEC/Main concatMap _ _ @ []" [ALWAYS] forall @ a3
                                               @ b
                                               $dFoldable :: Data.Foldable.Foldable []
  Data.Foldable.concatMap @ a3 @ b @ [] $dFoldable
  = Main.$sconcatMap @ a3 @ b
"SPEC/Main fromListWithKey @ RleEntry _" [ALWAYS] forall @ a
                                                         $dOrd :: GHC.Classes.Ord Main.RleEntry
  Data.Map.Strict.fromListWithKey @ Main.RleEntry @ a $dOrd
  = Main.$sfromListWith_$sfromListWithKey @ a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

